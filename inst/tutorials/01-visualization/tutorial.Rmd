---
title: "Visualization"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
author: Jessica Edwards
runtime: shiny_prerendered
description: "Gov 50: Data Chapter 1 Tutorial"
---

<!-- Ch. 1 tutorial questions written by Jessica Edwards, Connor Rust and Liam Rust  -->
<!-- Also includes questions from rstudio/learnr and rstudio-education/primers GitHub repos -->

```{r setup, include=FALSE}
library(tidyverse)
library(PPBDS.data)
library(learnr)
library(shiny)

library(ggthemes)
library(viridis)
library(nycflights13)

knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60)  
```

## Welcome!

Welcome to your first Gov 50 tutorial on Chapter 1: Visualization! We hope that this tutorial will be a great opportunity for you to learn and dive deeper into the course material. Most of these tutorial questions will be exercises in which you can put your coding skills to the test to practice all of the cool visualization techniques you read about in Chapter 1, but you will also test your knowledge in multiple choice and short answer questions. Let's get started!!

## How do I code in R?

R is easiest to use when you know how the R language works. Some of the basic programming topics in R include the following:

* **functions** and their **arguments**
* **objects**
* R's basic **data types** 
* R's basic data structures including **vectors** and **lists**
* R's **package system**

### Load a package

In the code chunk below, load the `tidyverse` package. Whenever you load a package R will also load all of the packages that the first package depends on. `tidyverse` takes advantage of this to create a shortcut for loading several common packages at once. Whenever you load `tidyverse`, `tidyverse` also loads `ggplot2`, `dplyr`, `tibble`, `tidyr`, `readr`, and `purrr`.

```{r packages2, exercise = TRUE}

```

### Quotes

Did you know, `library()` is a special function in R? You can pass `library()` a package name in quotes, like `library("tidyverse")`, or not in quotes, like `library(tidyverse)`---both will work! That's often not the case with R functions.

### Install packages

But what if the package that you want to load is not installed on your computer? How would you install the dplyr package on your own computer?

```{r packages3, exercise = TRUE}

```

### 

*Load the `ggplot2` package using `library()`.*

```{r exercise-1, exercise = TRUE, exercise.lines = 3}

```

### Functions 

Can you use the `sqrt()` function in the chunk below to compute the square root of 962?

```{r functions-1, exercise = TRUE}

```

Use the code chunk below to examine the code that `sqrt()` runs.

```{r functions-2, exercise = TRUE}
sqrt
```

Compare the code in `sqrt()` to the code in another R function, `lm()`. Examine `lm()`'s code body in the chunk below.

```{r functions-3, exercise = TRUE}
lm
```

### help pages

Wow! `lm()` runs a lot of code. What does it do? Open the help page for `lm()` in the chunk below and find out.

```{r functions-4, exercise = TRUE}

```

### Code comments

What do you think the chunk below will return? Run it and see. The result should be nothing. R will not run anything on a line after a `#` symbol. This is useful because it lets you write human readable comments in your code: just place the comments after a `#`. Now delete the `#` and re-run the chunk. You should see a result.

```{r functions-5, exercise = TRUE}
# sqrt(961)
```

### Objects

#### Object names

You can choose almost any name you like for an object, as long as the name does not begin with a number or a special character like `+`, `*`, `-`, `/`, `^`, `!`, `@`, or `&`. 

```{r objects-1, echo = FALSE}
question("Which of these would be valid object names?",
  answer("today", correct = TRUE),
  answer("1st"),
  answer("+1"),
  answer("vars", correct = TRUE),
  answer("\\^_^"),
  answer("foo", correct = TRUE),
  allow_retry = TRUE,
  correct = "Remember that the most helpful names will remind you what you put in your object."
)
```

#### Using objects

In the code chunk below, save the results of `rnorm(100, mean = 100, sd = 15)` to an object named `data`. Then, on a new line, call the `hist()` function on `data` to plot a histogram of the random values.

```{r objects-2, exercise=TRUE}

```

#### What if?

What do you think would happen if you assigned `data` to a new object named `copy`, like this? Run the code and then inspect both `data` and `copy`.

```{r objects-3, exercise=TRUE}
data <- rnorm(100, mean = 100, sd = 15)
copy <- data
```

#### Data sets

Objects provide an easy way to store data sets in R. In fact, R comes with many toy data sets pre-loaded. Examine the contents of `iris` to see a classic toy data set. Hint: how could you learn more about the `iris` object?

```{r objects-4, exercise = TRUE}

```

#### A common error

```{r packages1, echo = FALSE}
question('What does this common error message suggest? `object _____ does not exist.`',
         answer("You misspelled your object name"),
         answer("You've forgot to load the package that ____ comes in"),
         answer("Either", correct = TRUE),
         allow_retry = TRUE)
```

### Vectors

#### Create a vector

In the chunk below, create a vector that contains the integers from one to ten.

```{r vectors-1, exercise = TRUE}

```

```{r vectors-1-hint, eval=FALSE}
c(...)
```

#### `:`

If your vector contains a sequence of contiguous integers, you can create it with the `:` shortcut. Run `1:10` in the chunk below. What do you get? What do you suppose `1:20` would return?

```{r vectors-2, exercise = TRUE}

```

#### `[]`

You can extract any element of a vector by placing a pair of brackets behind the vector. Inside the brackets place the number of the element that you'd like to extract. For example, `vec[3]` would return the third element of the vector named `vec`.

Use the chunk below to extract the fourth element of `vec`.

```{r vectors-3, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
```

#### More `[]`

You can also use `[]` to extract multiple elements of a vector. Place the vector `c(1,2,5)` between the brackets below. What does R return?

```{r vectors-4, exercise = TRUE}
vec <- c(1, 2, 4, 8, 16)
vec[]
```

#### Names

If the elements of your vector have names, you can extract them by name. To do so place a name or vector of names in the brackets behind a vector. Surround each name with quotation marks, e.g. `vec2[c("alpha", "beta")]`.

Extract the element named gamma from the vector below.

```{r vectors-5, exercise = TRUE}
vec2 <- c(alpha = 1, beta = 2, gamma = 3)
```

#### Vectorised operations

Predict what the code below will return. Then look at the result.

```{r vectors-6, exercise = TRUE}
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) + c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

#### Vector recycling

Predict what the code below will return. Then look at the result.

```{r vectors-7, exercise = TRUE}
1 + c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

### Types

#### Data types
 
```{r flights3, echo = FALSE}
flights
``` 
 
Did you notice that a row of three (or four) letter abbreviations appears under the column names of `flights`? These abbreviations describe the _type_ of data that is stored in each column of `flights`:

* `int` stands for integers.

* `dbl` stands for doubles, or real numbers.

* `chr` stands for character vectors, or strings.

* `dttm` stands for date-times (a date + a time).

There are three other common types of variables that aren't used in this dataset but are used in other datasets:

* `lgl` stands for logical, vectors that contain only `TRUE` or `FALSE`.

* `fctr` stands for factors, which R uses to represent categorical variables
  with fixed possible values.

* `date` stands for dates.

This row of data types is unique to tibbles and is one of the ways that tibbles try to be more user-friendly than data frames.

#### Vectors

```{r types5, echo = FALSE}
question('How many types of data can you put into a single vector?',
         answer("1", correct = TRUE),
         answer("6"),
         answer("As many as you like"),
         allow_retry = TRUE)
```

#### Character or object?

One of the most common mistakes in R is to call an object when you mean to call a character string and vice versa.

```{r types6, echo = FALSE}
question('Which of these are object names? What is the difference between object names and character strings?',
         answer("foo", correct = TRUE),
         answer('"num"'),
         answer("mu", correct = TRUE),
         answer('"sigma"'),
         answer('"data"'),
         answer("a", correct = TRUE),
         allow_retry = TRUE,
         correct = "Character strings are surrounded by quotation marks, object names are not.")
```

### Lists 

#### Lists vs. vectors

```{r lists1, echo = FALSE}
question('Which data structure(s) could you use to store these pieces of data in the same object? `1001`, `TRUE`, `"stories"`.',
         answer("a vector"),
         answer("a list", correct = TRUE),
         answer("neither"),
         allow_retry = TRUE)
```

#### Make a list

Make a list that contains the elements `1001`, `TRUE`, and `"stories"`. Give each element a name.

```{r lists2, exercise = TRUE}

```

#### Extract an element

Extract the number 1001 from the list below.

```{r lists3, exercise = TRUE}
things <- list(number = 1001, logical = TRUE, string = "stories")
```

#### Data Frames

You can make a data frame with the `data.frame()` function, which works similar to `c()`, and `list()`. Assemble the vectors below into a data frame with the column names `numbers`, `logicals`, `strings`.

```{r lists4, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
```

#### Extract a column

Given that a data frame is a type of list (with named elements), how could you extract the strings column of the `df` data frame below? Do it.

```{r lists5, exercise = TRUE}
nums <- c(1, 2, 3, 4)
logs <- c(TRUE, TRUE, FALSE, TRUE)
strs <- c("apple", "banana", "carrot", "duck")
df <- data.frame(numbers = nums, logicals = logs, strings = strs)
```

## Exploring data frames

### `trains` dataset

Load the `PPBDS.data` package to look at the `trains` dataset.
```{r exercise-2, exercise = TRUE, exercise.lines = 5}

  
trains
```

Use the `glimpse()` function to look at the `trains` dataset. We already loaded the `tidyverse` and `PPBDS.data` packages.
```{r exercise-4, exercise = TRUE, exercise.lines = 5}
library(tidyverse)
library(PPBDS.data)


```

```{r quiz-4, echo = FALSE}
quiz(caption = "Quiz - `trains` dataset",
  question("What is the data type of the `liberal` variable?",
           answer("character"),
           answer("logical", correct = TRUE),
           answer("double"),
           answer("factor"),
           allow_retry = TRUE
  ),
  question("How many rows does the `train` dataset have?",
           answer("8"),
           answer("15"),
           answer("115", correct = TRUE),
           allow_retry = TRUE
  )
)
```

Extract the `income` variable in the `trains` dataset using the `$` operator.
```{r exercise-5, exercise = TRUE}

```

### `qscores` dataset

Look at the `qscores` dataset using `glimpse()`. We have loaded the `PPBDS.data` and the `tidyverse` packages.

```{r qscores, exercise = TRUE, exercise.lines = 5}

```

```{r quiz-5, echo = FALSE}
quiz(
  question("Which of the following is NOT an identification variable? (choose 2)",
           answer("`name`"),
           answer("`department`", correct = TRUE),
           answer("`workload`", correct = TRUE),
           answer("`number`"),
           allow_retry = TRUE
  )
)
```

## Grammar of graphics

```{r quiz-6, echo = FALSE}
quiz(
  question("What are the three essential components of a graphic?",
           answer("the dataset containing the variables in question", correct = TRUE),
           answer("the geometric object we can observe in a plot", correct = TRUE),
           answer("axes labels on a plot"),
           answer("the aesthetic attributes", correct = TRUE),
           allow_retry = TRUE
  ),
  question("What are the two important arguments that we need to provide the `ggplot()` function?",
           answer("`data` and `mapping`", correct = TRUE),
           answer("`data` and `aesthetics`"),
           answer("`data` and `layers`"),
           allow_retry = TRUE
  )
)
```

### Components of a scatterplot

Look at this scatterplot made using the `trains` dataset. Higher numbers mean more conservative attitudes toward immigration-related policies on a 3 to 15 scale. Individuals with a treatment value of "Treated" were exposed to two Spanish-speakers on their regular commute. "Control" individuals were not.

```{r trains}
ggplot(data = trains, mapping = aes(x = att_start, y = att_end, color = treatment)) +
  geom_point() + facet_wrap(~party)
```

```{r quiz-7, echo = FALSE}
quiz(
  question("Which `data` variable is mapped to the `x`-position `aes`thetic of the points?",
           answer("`att_start`", correct = TRUE),
           answer("`att_end`"),
           answer("`treatment`"),
           allow_retry = TRUE
  ),
  question("Which `data` variable is mapped to the `y`-position `aes`thetic of the points?",
           answer("`att_start`"),
           answer("`att_end`", correct = TRUE),
           answer("`treatment`"),
           allow_retry = TRUE
  ),
  question("Which `data` variable is mapped to the `color` `aes`thetic of the points?",
           answer("`att_start`"),
           answer("`att_end`"),
           answer("`treatment`", correct = TRUE),
           allow_retry = TRUE
  )
)
```

## `geom_point()` 
<!-- I -->

Let's make a scatterplot using the `iris` dataset. Hit the 'Run Code' button.

```{r gp-1-1, exercise=TRUE, eval=FALSE}
ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width)) + 
  geom_point()
```

###

Great! Now try making a scatterplot with x = `Sepal.Length` and y = `Sepal.Width`.

```{r gp-1-2-hint, eval=FALSE}
ggplot(data = iris, aes(x = ..., y = ...)) + 
  geom_point()
```

```{r gp-1-2, exercise=TRUE, exercise.lines = 5}
  

```

###

Excellent work! Now let's make a scatterplot with `Sepal.Length` on the x-axis, and `Petal.Length` on the y-axis. 

```{r gp-1-3, exercise=TRUE, exercise.lines = 5}
  

```

Wonderful. Now use what you've learned to recreate the plot below.

```{r}
ggplot(
  data = iris, mapping = aes(x = Petal.Width, y = Sepal.Width)) +
    geom_point() + 
    labs(title = "Petal and Sepal Widths in Irises")
```

```{r gp-1-5-hint, eval=FALSE}
To create a title, use labs(title = ...).
```

```{r gp-1-5, exercise=TRUE, exercise.lines = 5}
  

```

<!-- ## `geom_point()` II -->

### Scatterplot with the `qscores` dataset

Now let's make a scatterplot using the `qscores` dataset. Load the `PPBDS.data` package and look at the `qscores` dataset by simply typing the name of the dataset.

```{r exercise-6, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-6-hint, eval=FALSE}
library(...)

...
```

###

Nice! Load the `ggplot2` package. Use the `ggplot()` function to create a scatterplot using the `qscores` dataset, `rating` on the x-axis and `hours` on the y-axis. Is there a relationship between the rating of a Harvard course versus the average hours per week of workload?

```{r exercise-7, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-7-hint, eval=FALSE}
library(...)

ggplot(data = qscores, mapping = aes(x = ..., y = ...)) +
  ...
```

###

Awesome! Now we want to add a `size` `aes`thetic based on the number of students enrolled in each course. Add `size = enrollment` to the other `aes`thetics of the points. Do larger classes have a higher average overall course rating? What about higher workload?

```{r exercise-8, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours)) +
  geom_point()
```

```{r exercise-8-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = ...)) +
  geom_point()
```

<!-- ## `geom_point()` III -->

###

For the dataset `sps`, make a scatterplot with `age` on the x-axis and `health_exp_3m` on the y-axis.

```{r point-I-2, exercise=TRUE, exercise.lines=5}

```


```{r point-I-2-hint, eval=FALSE}
ggplot(data = sps, aes(x = ..., y = ...)) +
  geom_point()
```

###

Nice job! As you can see, our plot has many overlapping points making it hard to tell what's going on. Let's change the opacity by setting the `alpha` argument to 0.1.

```{r point-I-3, exercise=TRUE, exercise.lines=8, eval=FALSE}
ggplot(data = sps, aes(x = age, y = health_exp_3m)) +
  geom_point()
```

```{r point-I-3-hint, eval=FALSE}
Set the alpha argument inside of geom_point()
```

###

Great! Now try mapping the `sex` variable to the `color` aesthetic.

```{r point-I-4, exercise=TRUE, exercise.lines=10, eval=FALSE}
ggplot(data = sps, aes(x = age, y = health_exp_3m)) +
  geom_point()
```

```{r point-I-4-hint, eval=FALSE}
ggplot(aes(x = age, y = health_exp_3m, color = ...))

```

<!-- ## `geom_point()` IV -->

### Overplotting

While this plot created using the `mpg` dataset only displays 126 points, it visualizes a data set that contains 234 points.

```{r echo = FALSE, out.width = "80%"}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

The missing points are hidden behind other points, a phenomenon known as _overplotting_. Overplotting is a problem because it provides an incomplete picture of the dataset. You cannot determine where the *mass* of the points fall, which makes it difficult to spot relationships in the data. 

### Causes of overplotting

Overplotting usually occurs for two different reasons:

1. The data points have been rounded to a "grid" of common values, as in the plot above
2. The dataset is so large that it cannot be plotted without points overlapping each other

How you deal with overplotting will depend on the cause. 

### Changing the transparency

If your overplotting is due to rounding, you can obtain a better picture of the data by making each point semi-transparent. For example you could _set_ the alpha aesthetic of the plot below to a _value_ less than one, which will make the points transparent. 

Try this now. Set the points to an alpha of 0.2, which will make each point 20% opague (i.e. five points staked on top of each other will create a solid black).

*Change the transparency of the points by setting `alpha = 0.2` within `geom_point()`.*

```{r exercise-9, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = enrollment)) +
  geom_point()
```

```{r exercise-9-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating, y = hours, size = enrollment)) +
  geom_point(alpha = ...)
```

## `geom_jitter()` 
<!-- I -->

A second strategy for dealing with overplotting due to rounding is to adjust the position of each point. `geom_jitter()` plots a scatterplot and then adds a small amount of random noise to each point in the plot. It is a shortcut for adding a "jitter" position adjustment to a points plot (i.e, `geom_point(position = "jitter")`). Since the noise is random, it is unlikely that two points rounded to the same location will also be jittered to the same location. The result is a jittered plot that displays more of the data and provides a simple way to inspect patterns that occur in heavily gridded or overlapping data. 

*Replace `geom_point()` with `geom_jitter()` to create a jittered scatterplot.*

```{r exercise-10, exercise = TRUE, exercise.lines = 5}
ggplot(data = qscores, mapping = aes(x = rating, y = hours)) +
  geom_point()
```

### Strategies for large data

Alpha and jittering are less useful for large data. Jittering will not separate the points, and a mass of transparent points can still look black.

A better way to deal with overplotting due to large data is to visualize a summary of the data, by using a histogram or a linegraph, for example.

<!-- ## `geom_jitter()` II -->

###

Do you notice anything wrong with this graph? It appears to look fine, right? Try replacing `geom_point()` with `geom_jitter()`.

```{r jit-I-1, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, aes(x = att_start, y = att_end)) +
  geom_point()

```

###

As you can see, this changes things. The data on our graph was affected by overplotting, which is where points are plotted on top of each other. Jittering the points shifted them slightly from under each other. We can adjust the amount the points are jittered by setting the width. Set the `width` to `.2` within `geom_jitter()`.

```{r jit-I-3, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, aes(x = att_start, y = att_end)) +
  geom_jitter()

```
###

Now set the `color` aesthetic to the `party` variable. 

```{r jit-I-4, exercise=TRUE, exercise.lines=6}
ggplot(data = trains, aes(x = att_start, y = att_end)) +
  geom_jitter()

```


```{r jit-I-4-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes()
```

<!-- ## `geom_jitter()` III -->

Hit 'Run Code' to look at the following graph:

```{r gj-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = carat, y = price)) +
  geom_jitter()
```

###

`geom_jitter()` is really useful in graphs with a lot of overplotting like the one we just made, because it moves points that occupy the same location on the graph around so they're more visible. That being said, our graph still has a lot of overplotting.

Let's try to fix this by setting `width` to 0.25, to widen our jitter effect.

```{r gj-1-2, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = carat, y = price)) +
  geom_jitter()
```

###

Very nice, this gives us a bit of a better sense of the total distribution. But, there's still a lot of overplotting. Let's set the `alpha` value of our points to 0.2, so we can get a bit of a better grasp on our graph.

```{r gj-1-3, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = carat, y = price)) +
  geom_jitter()
```

###

Nice. Now, use what you've learned to recreate the plot below. The `alpha` of the plot is 0.2, and the `width` of the jitter distribution is 5.

```{r}
ggplot(data = diamonds, aes(x = depth, y = price)) +
  geom_jitter(width = 5, alpha = 0.2) +
  labs(title = "Depth and Price in Diamonds",
       x = "Depth",
       y = "Price")
```

```{r gj-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_line()` 
<!-- I -->

```{r, include = FALSE}
cces_data <- cces %>%
  filter(approval_ch %in% c("Approve / Somewhat Approve", "Disapprove / Somewhat Disapprove")) %>%
  group_by(year, approval_ch) %>%
  summarize(avg_age = mean(age))
```

The `cces` dataset in the `PPBDS.data` package has been changed to show the average age of voters per year based on their approval of the president that year. The `cces` dataset was manipulated using the `filter()`, `group_by`, and `summarize()` functions within the `tidyverse` package, which you will learn how to use in the next chapter.

```{r, echo = TRUE}
cces_data
```

Use the `ggplot()` function to create a linegraph with the dataset called `cces_data` with `year` on the x-axis, `avg_age` on the y-axis, and `approval_ch` as the color aesthetic.

```{r exercise-11-setup, include = FALSE}
cces_data <- cces %>%
  filter(approval_ch %in% c("Approve / Somewhat Approve", "Disapprove / Somewhat Disapprove")) %>%
  group_by(year, approval_ch) %>%
  summarize(avg_age = mean(age))
```

```{r exercise-11, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-11-hint, eval=FALSE}
ggplot(data = cces_data, mapping = aes(x = ..., y = ..., color = ...)) +
  geom_line()
```

### Test your knowledge

```{r quiz-8, echo = FALSE}
quiz(
  question("True / False: Linegraphs and scatterplots both display the relationship between two numerical variables.",
           answer("True", correct = TRUE),
           answer("False"),
           allow_retry = TRUE),
  question("True / False: It is preferred to use scatterplots over linegraphs when the variable on the x-axis has an inherent ordering, like in a time series plot.",
           answer("True"),
           answer("False", correct = TRUE),
           allow_retry = TRUE)
)
```

<!-- ## `geom_line()` II -->
###

Run the following line graph, then try changing the y axis variable to `unemploy`.

```{r line-I-2, exercise=TRUE, exercise.lines=6, eval=FALSE}
ggplot(data = economics, aes(x = date, y = pop)) +
  geom_line()
```

Nice! As you can see, we have filtered the data set `population` by `country` to create the new data frame `Afghanistan_population` which only includes data on Afghanistan. Use `Afghanistan_population` to create a line graph with `year` on the x axis and `population` (a variable that happens to have the same name as the data set) on the y axis.

```{r line-I-3, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")

```

```{r line-I-3-hint, eval=FALSE}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")

ggplot(data = ..., aes(x = ..., y = ...)) +
  geom_line()
```

###

Now change the line color to "purple"

```{r line-I-4, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")


```

```{r line-I-4-hint, eval=FALSE}

Set the color argument in geom_line() to "purple"

```

###

Great! For a final challenge, add a title and labels to both axes

```{r line-I-5, exercise=TRUE, exercise.lines=10}
Afghanistan_population <- population %>%
  filter(country == "Afghanistan")


```

```{r line-I-5-hint, eval=FALSE}
Use labs()

```

## `geom_histogram()` 
<!-- I -->

### Test your knowledge

```{r quiz-9, echo = FALSE}
quiz(
  question("A histogram is:",
           answer("A plot that displays the relationship between two numerical variables"),
           answer("A plot that visualizes the distribution of a numerical variable", correct = TRUE),
           answer("A plot that visualizes the distribution of a categorical variable"),
           allow_retry = TRUE)
)
```

###

Using the `qscores` dataset and `ggplot()`, make a histogram where `rating` is on the x-axis to see the distribution of Harvard course ratings.

```{r exercise-12, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-12-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

```{r quiz-10, echo = FALSE}
quiz(
  question_text("What is the default value of `bins` for this histogram? (Hint: all geoms have the same default values)",
                answer("30", correct = TRUE),
                allow_retry = TRUE)
)
```

###

Add white vertical borders demarcating the bins by adding `color = "powderblue"` and `fill = "red4"` arguments to `geom_histogram()`.

```{r exercise-13, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-13-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(color = ..., fill = ...)
```

###

Specify the number of bins to be 10 via the `bins` argument and the `color` as "white" in `geom_histogram()`.

```{r exercise-14, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-14-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(bins = ..., color = ...)
```

###

Specify the width of the bins to be 1 via the `binwidth` argument and the `color` as "white" in `geom_histogram()`.

```{r exercise-15, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-15-hint, eval=FALSE}
ggplot(data = qscores, mapping = aes(x = rating)) +
  geom_histogram(binwidth = ..., color = ...)
```

<!-- ## `geom_histogram()` II -->
###

Let's make a histogram using geom_histogram() and the `mpg` tibble, which contains data on the fuel efficiency of different types of cars. Press 'Run Code' to continue.

```{r gh-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = mpg, aes(x = hwy)) +
  geom_histogram()
```

###

Great. Note that if you don't specify the number of 'bins' you want for your histogram, R will generate a red message, even though there isn't an error.

###

Now, try making a histogram with x = `cty`.

```{r gh-1-2-hint, eval=FALSE}
ggplot(data = mpg, aes(x = ...)) +
  geom_histogram()
```

```{r gh-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now, let's get rid of that pesky red message by setting `bins` to 40.

```{r gh-1-3-hint, eval=FALSE}
ggplot(data = mpg, aes(x = ...)) +
  geom_histogram(bins = ...)
```

```{r gh-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Very nice. Now, use what you've learned to recreate this graph.

```{r}
ggplot(data = mpg, aes(x = displ)) +
  geom_histogram(bins = 10) +
  labs(title = "Engine Size in Cars",
       x = "Engine Size (Liters)",
       y = "Number of Car Models")
```


```{r gh-1-5-hint, eval=FALSE}
Engine size is recorded with the `displ` variable, and there are 10 bins in the plot.
Use labs(title = ..., x = ..., y = ...) to add the labels.
```

```{r gh-1-5, exercise=TRUE, exercise.lines = 7}

```

## `geom_boxplot()` 
<!-- I -->

```{r quiz-11, echo = FALSE}
quiz(
  question("Which of the following are included in the five-number summary of a numerical variable used to construct a boxplot?",
           answer("Minimum", correct = TRUE),
           answer("First quartile", correct = TRUE),
           answer("Median", correct = TRUE),
           answer("Mean"),
           answer("Third quartile", correct = TRUE),
           answer("Maximum", correct = TRUE)
  )
)
```

###

Let's keep playing with the `qscores` dataset in the `PPBDS.data` package. We have filtered the dataset using the `tidyverse` package based on the five departments with the classes with the most enrollment: ECON, COMPSCI, STAT, GOV, and MATH. The filtered dataset is called `top_five_qscores`.

```{r, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r, echo = TRUE}
top_five_qscores
```

### 

Using the `top_five_qscores` dataset and `ggplot()`, make a boxplot where `department` is on the x-axis and `rating` is on the y-axis.

```{r exercise-16-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```


```{r exercise-16, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-16-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ..., y = ...)) +
  ...
```

```{r quiz-12, echo = FALSE}
quiz(
  question("Which department has the highest median course rating?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV"),
           answer("MATH", correct = TRUE),
           answer("STAT")
  ),
  question("Which department has outliers?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV"),
           answer("MATH", correct = TRUE),
           answer("STAT")
  ),
  question("Which department has the largest range of course ratings?",
           answer("COMPSCI"),
           answer("ECON"),
           answer("GOV", correct = TRUE),
           answer("MATH"),
           answer("STAT")
  )
)
```

<!-- ## `geom_boxplot()` II -->
###

Using the `trains` dataset, create a boxplot with `party` on the x-axis and `att_start` on the y-axis.

```{r box-I-2, exercise=TRUE, exercise.lines = 10, eval=FALSE}

```

###

Using the dataset `governors`, create a boxplot where `party` is on the x-axis and `win_margin` is on the y-axis.

```{r box-I-3, exercise=TRUE, eval=FALSE, exercise.lines=10}

```

###

Let's add some color! Change your previous boxplot so that it is outlined in blue
```{r box-I-4, exercise=TRUE, eval=FALSE, exercise.lines=10}

```

```{r box-I-4-hint,eval=FALSE}
Use the color argument and remember to put "blue" in quotes.
```

<!-- ## `geom_boxplot()` III -->
###

Let's make a boxplot using the `mpg` tibble, which shows the fuel efficiency for different types of cars. Set x = `class`, and y = `hwy`.

```{r gb-1-2-hint, eval=FALSE}
ggplot(data = mpg, aes(x = ... , y = ... )) +
  geom_boxplot()
```

```{r gb-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now let's make the outliers a little bit easier to see. Set `outlier.size` to 4, and `outlier.fill` to "red".

```{r gb-1-3-hint, eval=FALSE}
Put `outlier.size` and `outlier.fill` inside of geom_boxplot().
```

```{r gb-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now let's add some labels using the `labs()` function. Title the plot "Highway Fuel Efficiency in Different Types of Cars", make x = "Type of Car", and make y = "Miles Per Gallon (Highway)".

```{r gb-1-4-hint, eval=FALSE}
labs(title = ...,
     x = ...,
     y = ...)
```

```{r gb-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Awesome! Now, use what you've learned to recreate this plot.

```{r}
ggplot(data = mpg, aes(x = manufacturer, y = cty)) +
  geom_boxplot(outlier.color = "blue") +
  labs(title = "City Fuel Effiecnecy by Car Manufacturer",
       x = "Manufacturer",
       y = "Miles Per Gallon (City)")
```

```{r gb-1-5, exercise=TRUE, exercise.lines = 5}

```

## `geom_violin()` 
<!-- I -->

Let's use `geom_violin()` to make a plot with the `diamonds` tibble, which contains information about cut diamonds. Hit 'Run Code' to continue.

```{r gv-1-1, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = cut, y = price)) +
  geom_violin()
```

###

Nice. Now, let's try changing the `color`, or outline, of our plot to "red" and the `fill` of the plots to "red3" within `geom_violin()`.

```{r gv-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Cool. Now, let's use `draw_quantiles` to draw percentile lines on our violins, at 0.25, 0.5, and 0.75. `draw_quantiles` is an argument that goes within the `geom_violin()` function.

```{r gv-1-4-hint, eval=FALSE}
draw_quantiles = c(..., ..., ...)
```

```{r gv-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now try doubling the bandwith using the `adjust` argument in `geom_violin()`.

```{r viol-I-3, exercise=TRUE, exercise.lines=8}

```

```{r viol-I-3-hint, eval=FALSE}
adjust = 2
```

###

Nice! Now try setting the `kernel` argument in `geom_violin()` to "epanechnikov".

```{r viol-I-4, exercise=TRUE, exercise.lines=8}

```

###

Well done. Now, use what you've learned about `geom_violin()` to recreate this plot:

```{r}
ggplot(data = diamonds, aes(x = cut, y = carat), color = "blue") +
  geom_violin() +
  labs(title = "Size and Quality in Diamonds",
       x = "Quality",
       y = "Size (Carats)")
```

```{r gv-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r gv-1-5-hint, eval=FALSE}
aes(x = cut, y = carat)

labs(title = ..., x = ..., y = ...)
```

## geom_bar() and geom_col()

```{r quiz-13, echo = FALSE}
quiz(
  question("A barplot is:",
           answer("A plot that displays the relationship between two numerical variables"),
           answer("A plot that visualizes the distribution of a numerical variable"),
           answer("A plot that visualizes the distribution of a categorical variable",
                  correct = TRUE),
           allow_retry = TRUE)
)
```

###

*We can now use a barplot to plot how many students are enrolled in classes per department. We will use the `top_five_qscores` dataset again to look at the five largest departments.*

```{r barplot, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r barplot-top-five-qscores, echo = TRUE}
top_five_qscores
```

*Use `ggplot()` and `geom_bar()` to plot `department` on the x-axis to see the number of classes in each department.*

```{r exercise-17-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])
```

```{r exercise-17, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-17-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) +
  ...
```

###

*We can then count the number of classes per department in order to use the `geom_col()` layer instead. We do this using the `group_by()` and `count()` functions in the `tidyverse` package, which you will learn how to use in the next chapter. Our new data frame is stored as `top_five_qscores_counted`.*

```{r classes-counted, include = FALSE}
top_five_qscores_counted <- top_five_qscores %>%
  group_by(department) %>% count() %>% rename(count = n)
```

```{r avg-workload, echo = TRUE}
top_five_qscores_counted
```

*Use `ggplot()` and `geom_col()` to plot `department` on the x-axis and `count` on the y-axis to see the number of classes in each department.*

```{r exercise-18-setup, include = FALSE}
top_five_enrolled <- qscores %>%
  group_by(department) %>%
  summarize(enrollment = sum(enrollment)) %>%
  arrange(desc(enrollment)) %>%
  pull(department)

top_five_qscores <- qscores %>% filter(department %in% top_five_enrolled[0:5])

top_five_qscores_counted <- top_five_qscores %>%
  group_by(department) %>% count() %>% rename(count = n)
```


```{r exercise-18, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-18-hint, eval=FALSE}
ggplot(data = top_five_qscores_counted, mapping = aes(x = ..., y = ...)) +
  ...
```

```{r quiz-14, echo = FALSE}
quiz(
  question("What's the difference between `geom_bar()` and `geom_col()`?",
           answer("`geom_bar()` is used to represent pre-counted data while `geom_col() is not."),
           answer("`geom_col()` is used to represent pre-counted data while `geom_bar() is not.",
                  correct = TRUE),
           answer("There is no difference between the two layers.")
  )
)
```

###

*Let's go back to the `trains` dataset in the `PPBDS.data` package. Use `ggplot()` and `geom_bar()` to plot `treatment` on the x-axis.*

```{r exercise-19, exercise = TRUE, exercise.lines = 5}

```

```{r exercise-19-hint, eval=FALSE}
ggplot(data = ..., mapping = aes(x = ...)) + ...
```

###

*We can now map the additional variable `party` by adding a `fill = party` inside the `aes()` aesthetic mapping.*

```{r exercise-20, exercise = TRUE, exercise.lines = 5}
ggplot(data = trains, mapping = aes(x = treatment)) + geom_bar()
```

```{r exercise-20-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = ...)) + geom_bar()
```

###

*Change `fill = party` to `color = party`. What happens? *

```{r exercise-21, exercise = TRUE, exercise.lines = 5}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) + geom_bar()
```

###

*Create a side-by-side barplot by adding `position = "dodge"` to `geom_bar()`.*

```{r exercise-22, exercise = TRUE, exercise.lines = 5}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) +
  geom_bar()
```

```{r exercise-22-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment, fill = party)) +
  geom_bar(position = ...)
```

###

*Instead of mapping `party` to `fill`, we can include it as the variable to create small multiples of the plot across the levels of `party` using `facet_wrap(~ party)`. Add this layer to the provided plot in order to create a faceted barplot.*

```{r exercise-23, exercise = TRUE, exercise.lines = 5}
ggplot(data = trains, mapping = aes(x = treatment)) +
  geom_bar()
```

```{r exercise-23-hint, eval=FALSE}
ggplot(data = trains, mapping = aes(x = treatment)) + geom_bar() + ...
```

## geom_bar() I

###

Welcome to geom_bar() I! Let's start by looking at the data set `diamonds`, one you should already be familiar with. Press "Run Code"

```{r bar-I-1, exercise=TRUE, exercise.lines=7}
diamonds %>%
  ggplot(aes(x = color)) +
    geom_bar()


```

###

Now change the x axis variable to `cut` and run code the code chunk.

```{r bar-I-2, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-2-hint, eval=FALSE}
diamonds %>%
  ggplot(aes(x = ...)) +
    geom_bar()
```

###

Nice! Now try mapping the `fill` aesthetic to the `clarity` variable to create a stacked barplot

```{r bar-I-3, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-3-hint, eval=FALSE}
Because we are mapping fill to a variable, it is an aesthetic. This means that is has to be mapped inside of aes()
```

###

Great! Now try creating a dodged barplot by setting the `positon` argument to "dodge"


```{r bar-I-4, exercise=TRUE, exercise.lines=7}


```

```{r bar-I-4-hint, eval=FALSE}
Set position inside geom_bar() and remember to put "dodge" in quotes
```

###

```{r}
cces %>%
  ggplot(aes(x = ideology, fill = gender)) +
    geom_bar(position = "dodge")
```

For your final challenge, recreate the above dodged bar graph. Note, it was made from data set `cces` with the fill aesthetic set to `gender`.
```{r bar-I-5, exercise=TRUE, exercise.lines=7}


```
## geom_bar() II

###

Welcome to geom_bar() II! Using data set `sps`, a public health experiment in Mexico, make a dodged bar plot with `education` on the x axis and `sex` mapped to the fill aesthetic.

```{r bar-II-1, exercise=TRUE, exercise.lines=7}


```

###

Great! Try changing the scale with the function `scale_y_sqrt()`
```{r bar-II-2, exercise=TRUE, exercise.lines=7}


```

###

Nice! Now move the key to the bottom using the function `theme(legend.position = "bottom")`
```{r bar-II-3, exercise=TRUE, exercise.lines=7}


```

###

Now facet the graph by `treatment` and set the number of columns to 2.

```{r bar-II-4, exercise=TRUE, exercise.lines=7}


```

```{r bar-II-4-hint, eval=FALSE}
To facet, use facet_wrap() and inside, set ncol to 2

```
###

Nice! Now make the theme of the plot minimalist and add a title of your choice.

```{r bar-II-5, exercise=TRUE, exercise.lines=7}


```

```{r bar-II-5-hint, eval=FALSE}
To set the theme, use theme_minimal() and to add a title, use labs()

```

## geom_bar() III

Let's make a barplot using `geom_bar()` using the `trains` tibble, which records attitudes towards immigration on a Boston train platform before and after an experiment. Hit 'Run Code' to continue.


```{r gbr-1-1, exercise=TRUE, exercise.lines = 5}
trains %>% ggplot() +
  geom_bar(aes(x = party))
```

###

Nice. Now, let's try making a barplot with x = `gender` instead.

```{r gbr-1-2-hint, eval=FALSE}
trains %>% ggplot() +
  geom_bar(aes(x = ...))
```

```{r gbr-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Cool. Now, let's try adding some labels with `labs()`. Title our graph "Gender Distribution on Boston Train Platform". Our x-axis can be "Gender", and our y-axis can be "Number of People".

```{r gbr-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's try mapping `fill` to the `liberal` variable.

```{r gbr-1-4-hint, eval=FALSE}
Make sure to map `fill` inside of the `aes()` function.
```

```{r gbr-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Wonderful! Now, use what you've learned to recreate the plot below.

```{r gbr-1-5, exercise=TRUE, exercise.lines = 5}

```

```{r}
trains %>% ggplot() +
  geom_bar(aes(x = party, fill = liberal)) +
  labs(title = "Political Distribution on Boston Train Platform",
       x = "Political Party", y = "Number of People")
```

## geom_bar() IV

Let's make a barplot using `trains`, a tibble that records attitudes towards immigration on a Boston train platform before and after an experiment. Map our x variable to `att_start`.

```{r gbr-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, add some labels with `labs()`, let's title our plot "Attitudes Towards Immigration on Boston Train Platform", call our x-axis "Attitude Towards Immigration (Higher Means More Conservative)", and our y-axis "Number of People". Let's also map `fill` to `party`. Notice any patterns?

```{r gbr-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Let's change the aesthetics of our graph to make it a little more appealing. Let's change our theme using `theme_bw()`, and change our color scheme using `scale_color_brewer()`, and set our `palette` to "Purples".

```{r gbr-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, let's use `facet_wrap()` to divide our graph by the `liberal` variable.

```{r gbr-2-4-hint, eval=FALSE}
facet_wrap( ~ ...)
```

```{r gbr-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned to recreate the plot below.

```{r}
trains %>% ggplot() +
  geom_bar(aes(x = att_end, fill = gender)) +
  facet_wrap( ~ treatment) +
  labs(title = "Attitudes Towards Immigration After Experimentation",
       x = "Attitude Towards Immigration (Higher Means More Conservative)",
       y = "Number of People")
```

```{r gbr-2-5, exercise=TRUE, exercise.lines = 5}

```

## geom_col() I

###

Welcome to geom_col() I! `geom_col()` makes barplots just like `geom_bar`. The key difference between the two is the type of data they use. In the code below, I create a bar plot with the `qscores` dataset. Here, I used `geom_col` because the totals for enrollment were pre-counted and listed in the data set. So say for class 1OOY, instead of having 1OOY appear 50 times in the data set to tell us that there are 50 students, we just have the enrollment listed as 50. Also note that, unlike for `geom_bar`, we have to include both x and y in the aesthetic. Press "Run Code" to check out the graph:

```{r col-I-1, exercise=TRUE, exercise.lines=7}
qscores %>%
  filter(department == "AFRAMER") %>%
    ggplot(aes(x = number, y = enrollment)) +
      geom_col()

```

###

Let's make this graph a little more interesting. Map the `color` aesthetic to the `term` variable.

```{r col-I-2, exercise=TRUE, exercise.lines=7}


```

```{r col-I-2-hint, eval=FALSE}
qscores %>%
  filter(department == "AFRAMER") %>%
    ggplot(aes(x = number, y = enrollment, color = ...)) +
      geom_col()

```

###

Nice! Try swapping the variable `enrollment` from the x axis to the y axis and the variable `number` from the y axis to the x axis.

```{r col-I-3, exercise=TRUE, exercise.lines=7}


```

###

Hmm, what do you think of the changes. I think it looked better before, as it made more sense to have the continuous variable `enrollment` on the y axis. For this next code snippet, let's switch it back and add labels. Change axis label "number" to "class identification number", and add the title "Enrollment in Classes in the Department of African and African American Studies at Harvard".

```{r col-I-4, exercise=TRUE, exercise.lines=7}
construction %>%
  ggplot(aes(x = Month,y = Northeast)) +
    geom_line()

```

```{r col-I-4-hint, eval=FALSE}
To add labels, use labs()

```

###

This final question is for all you Star Wars fans out there. These are the droids you're looking for. Recreate the plot below which I created from filtering data set `starwars` to only characters who are droids. As you can see, I have started it for you.

```{r}
starwars %>%
  filter(species == "Droid") %>%
    ggplot(aes(x = name, y = height)) +
      geom_col()
```

```{r col-I-5, exercise=TRUE, exercise.lines=7, eval=FALSE}
starwars %>%
  filter(species == "Droid") %>%


```

## geom_col() II

###

Welcome to geom_col() II! Let's begin right where we left off with the data set `starwars`. Using `starwars` make a bar plot of only characters from Naboo with `name` on the x axis and `height` on the y axis. In order to do this, we must first filter by `homeworld`, which I have done for you below.

```{r col-II-1, exercise=TRUE, exercise.lines=7, eval=FALSE}
starwars %>%
  filter(homeworld == "Naboo") %>%

```

###

Great! Now set the `fill` aesthetic to the variable `sex`

```{r col-II-2, exercise=TRUE, exercise.lines=7}


```

```{r col-II-2-hint, eval=FALSE}
Because fill is an aesthetic, we set it inside aes()
```

###

Nice! As you can see, there is some overlapping text making it hard to read the x axis. Let's fix this by setting the x axis text size to 7 using theme().

```{r col-II-3, exercise=TRUE, exercise.lines=7}


```

```{r col-II-3-hint, eval=FALSE}
Use theme() and set axis.text.x to element_text(size 7)

```

###

Nice! Now try making the bars thinner by setting bar width to .5

```{r col-II-4, exercise=TRUE, exercise.lines=7}


```

```{r col-II-4-hint, eval=FALSE}
Set it inside of geom_col()
```

###


For your final challenge, recreate the plot below. It was made from the data set `qscores` and was filtered to only include data where `department` == `ENGLISH`. Additionally, the size of the text on the x axis was set to size 5 using theme(). I have started it for you below:

```{r}
qscores %>%
  filter(department == "ENGLISH") %>%
    ggplot(aes(x = number, y = hours)) +
      geom_col() +
      theme(axis.text.x = element_text(size = 5)) +
      labs(title = "Hours of Work in Harvard English Classes")
```

```{r col-II-5, exercise=TRUE, exercise.lines=7, eval=FALSE}
qscores %>%
  filter(department == "ENGLISH") %>%
```

```{r col-II-5-hint, eval=FALSE}
Use labs() to add a title and look back to question 3 to change the axis text size
```

## geom_col III

Let's use the `qscores` tibble, which contains student evaluation data from Harvard, to make a plot of the classes in the `MUSIC` department with `geom_col()`. Press 'Run Code' to make the plot.

```{r gc-1-1, exercise=TRUE, exercise.lines = 5}
qscores %>% 
  filter(department == "MUSIC") %>% 
  ggplot(aes(x = name, y = rating)) +
    geom_col()
```

###

Nicely done. Let's try making a plot with the same classes, but with `hours` on our y-axis instead of `rating`.

```{r gc-1-2-hint, eval=FALSE}
qscores %>% 
  filter(department == "MUSIC") %>% 
  ggplot(aes(x = ..., y = ...)) +
    geom_col()
```

```{r gc-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's add some labels with `labs()`. Title our plot "Harvard Music Department Class Student Ratings", our x-axis "Class Name", and our y-axis "Student Evaluation Rating".

```{r gc-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Good. Now, let's modify our plot so that `enrollment` goes on the y-axis instead of `rating`. We can also change our y-axis label to "Number of Students Enrolled". Let's also change the `fill` of our plot to "black".

```{r gc-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you know about `geom_col()` to replicate the plot below. Use `filter(department == "NEURO")`, and the variable `hours` for the y-axis.

```{r}
qscores %>% filter(department == "NEURO") %>% ggplot(aes(x = name, y = hours)) +
  geom_col() +
  labs(title = "Weekly Workload Hours in Neurology Classes at Harvard",
       x = "Class Name",
       y = "Weekly Workload Hours")
```

```{r gc-1-5, exercise=TRUE, exercise.lines = 5}

```

## geom_col() IV

Let's make a plot recording the fuel efficiency of different Toyota models with the `mpg` tibble, and `geom_col()`. Set x = `hwy`, and y = `cty`.

```{r gc-2-1-hint, eval=FALSE}
mpg %>% 
  filter(manufacturer == "toyota") %>%
```

```{r gc-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. But wait a second, our numbers seem way off! Because `geom_col()` uses the `stacked` position by default, it's lumping all the different car models with the same name on the same bar. Let's set our `position` to `dodge`, and continue. Let's also set `color` to "white" to make a white outline around our bars.

```{r gc-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Wonderful. Now, let's map `fill` to the `class` variable. Let's also make some labels for our legend. Note that this must be done inside of a `scale()` function. Let's make this `scale()` function `scale_fill_discrete()` for now, so it won't change anything except for our legend.

Let's call our legend "Car Types", and our variables "Small", "Medium", "Pickup Truck", and "SUV".

```{r gc-2-3-hint, eval=FALSE}
sacle_...(name = ..., labels = c(..., ..., ...))
```

```{r gc-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's use `labs()` to make some labels for the rest of our plot. Let's call our plot "Highway and City Fuel Economy in Toyota Cars", our x-axis "Miles Per Gallon (Highway)", and our y-axis "Miles Per Gallon (City)". Let's also change the theme of our plot to 'theme_classic()'

```{r gc-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Excellent. Now, use what you've learned about `geom_col()` to replicate the plot below. The theme is `theme_bw()`.

```{r}
mpg %>% 
  filter(manufacturer == "audi") %>% 
  ggplot(aes(x = displ, y = hwy, fill = drv)) +
    geom_col() +
    theme_bw() +
    scale_fill_discrete(name = "Drive Mode", 
                        labels = c("Front Only", "Four Wheel")) +
    labs(title = "Fuel Economy and Engine Size in Toyota Cars",
         x = "Engine Size (Liters)",
         y = "Miles Per Gallon (Highway)")
```

```{r gc-2-5, exercise=TRUE, exercise.lines = 5}

```

## geom_smooth() I

###

Welcome to geom_smooth() I! Let's start by creating a scatterplot from `nhanes`, which includes data from a national health and nutrition survey. Press "run code":

```{r smooth-I-1, exercise=TRUE, exercise.lines=7}
nhanes %>%
  ggplot(aes(x = weight, y = height)) +
    geom_point()

```

###

Now try adding `geom_smooth()` to the graph.

```{r smooth-I-2, exercise=TRUE, exercise.lines=7, eval=FALSE}
nhanes %>%
  ggplot(aes(x = weight, y = height)) +
    geom_point()


```

Nice! As you can see, the line you just graphed represents the trend that we see in the scatter plot. See the message that R gave us? Because we didn't set the method that R uses to calculate the line, R defaulted to using "gam". Let's try setting the method to "lm" instead.

```{r smooth-I-3, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-3-hint, eval=FALSE}
Set the method inside of geom_smooth() and remember to put "lm" in quotes
```

###

Great! Now get rid of the scatterplot by deleting `geom_point()` and only use `geom_smooth()`. Then, set the `color` aesthetic to the `gender` variable.

```{r smooth-I-4, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-4-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes()
```

###

Nice! Now add the the title "Height to Weight Relationship United States" and labels "height in cm" to the y axis and "weight in kg" to the x axis.

```{r smooth-I-5, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-5-hint, eval=FALSE}
use labs() to add the title and labels
```

## geom_smooth() II

###

Welcome to geom_smooth() II! Let's start by looking at the data set `trains`, which includes data on an experiment about attitudes towards immigration. Using `geom_smooth` and the "gam" method, create a graph from `trains` with `att_start` on the x axis and `att_end` on the y axis.

```{r smooth-II-1, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-1-hint, eval=FALSE}
... %>%
  ggplot(aes(x = ..., y = ...)) +
    geom_smooth(method = "...")
```

###

Nice! Now set the `color` aesthetic to the `treatment` variable and set alpha to .75.

```{r smooth-II-2, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-2-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes(). Set alpha inside of geom_smooth()
```

###

Great! Now move the legend to the top of the graph using `theme()`

```{r smooth-II-3, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-3-hint, eval=FALSE}
Set legend.position to "top"
```

###

Nice! As you can see, R has labelled the tick marks for 4, 8 and 12. Move them to 5, 10 and 15 instead on both axes.

```{r smooth-II-4, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-4-hint, eval=FALSE}
 Set the tickmarks through a vector inside of scale_y_continuous() and scale_x_continous()
```

###

Now set the theme to black and white. Then add the labels "attitude start" to the x axis and "attitude end" to the y axis.

```{r smooth-II-5, exercise=TRUE, exercise.lines=7}


```

```{r smooth-II-5-hint, eval=FALSE}
For the theme, use the theme_bw() function. To add labels, use labs()
```

## geom_smooth() III

Let's make a plot with `geom_smooth()`, and the `mpg` tibble, which records the fuel efficiency of different car models. Hit 'Run Code' to continue.

```{r gs-1-1, exercise=TRUE, exercise.lines = 5}
mpg %>% ggplot(aes(x = displ, y = cty)) +
  geom_smooth()
```

###

Nice. Now, let's make the gray confidence interval bar disappear by setting `se` to `FALSE`.

```{r gs-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Looks good! Let's add some labels with labs(). We can call our plot "Engine Size and City Fuel Efficiency", our x-axis "Engine Size (Liters)", and our y-axis "City Fuel Efficiency (Miles Per Gallon)"

```{r gs-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Now, let's try dividing up our trendline by mapping `color` to `class`, so we can get a better sense of the range of fuel efficiency in different types of cars.

```{r gs-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, use what you've learned about `geom_smooth()` to recreate the plot below.

```{r}
mpg %>% ggplot(aes(x = cty, y = hwy)) +
  geom_smooth( color = "red") +
  labs(title = "City vs. Highway Fuel Economy",
       x = "City Miles Per Gallon",
       y = "Highway Miles Per Gallon")
```

```{r gs-1-5, exercise=TRUE, exercise.lines = 5}

```

## geom_smooth() IV

Let's use the `iris` tibble, which records the dimensions of samples of iris flowers, and `geom_smooth()` to make a plot with x = `Petal.Length`, and y = `Petal.Width`.

```{r gs-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's map `color` to `Species`. Let's also use the "Reds" color scheme from `scale_color_brewer()`.

```{r gs-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's add some labels with `labs()`. Call our plot "Petal Length and Width in Iris Species", our x-axis "Petal Length", and our y-axis "Petal Height".

Let's also change the labels on our legend. Note that this must be done inside of our `scale()` function, because both the `scale()` function and the legend correspond to `color`. Let's call our legend "Iris Species", and our variables "Setosa Iris", "Blue Flag Iris", and "Virginia Iris".

```{r gj-2-3-hint, eval=FALSE}
sacle_...(name = ..., labels = c(..., ..., ...))
```

```{r gs-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's make our trendlines represent the linear mean of their data, by setting `method` to `lm`. Let's also use 'theme_bw()' theme, and move our legend to the bottom of our plot using `legend.position`. Remember that this must be done within a `theme()` function.

```{r gs-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, use what you've learned to recreate the graph below. The scale for the legend is "discrete", and the color is "purple". Good luck.

```{r}
iris %>% 
  ggplot(aes(x = Sepal.Width, y = Sepal.Length, linetype = Species)) +
    geom_smooth(se = FALSE, color = "purple") +
    labs(title = "Sepal Width and Length in Iris Species",
         x = "Sepal Width",
         y = "Sepal Height") +
    scale_linetype_discrete(name = "Iris Species:", 
                            labels = c("Setosa Iris:", "Blue Flag Iris:", 
                                       "Virginia Iris:")) +
    theme(legend.position = "top")
```

```{r gs-2-5, exercise=TRUE, exercise.lines = 5}

```

## geom_density() I

###

Welcome to geom_density() I! Just like histograms, density plots give us a sense of the distribution of a data set for a given variable.  Let's start by looking at this density plot from data set `nhanes`. Press "run code":

```{r den1D-I-1, exercise=TRUE, exercise.lines=6}
nhanes %>%
  ggplot(aes(x = bmi)) +
    geom_density()
```

###

Now try switching the axes by setting `bmi` to the y axis instead

```{r den1D-I-2, exercise=TRUE, exercise.lines=6}

```

###

Great! Now change the variable to `height` and set it to the x axis

```{r den1D-I-3, exercise=TRUE, exercise.lines=6}

```

###

Nice! Just like in a violin plot, we can use the `adjust` argument inside of `geom_density()` to change the bandwith of our plot. Try setting it to 1/3, which makes it a third of the size of the default

```{r den1D-I-4, exercise=TRUE, exercise.lines=6}

```

###

Great! Now set the `fill` aesthetic to the `gender` variable

```{r den1D-I-5, exercise=TRUE, exercise.lines=7}

```

```{r den1D-I-5-hint, eval=FALSE}
Because fill is an aesthetic, set it inside of aes()
```

## geom_density() II

###

Welcome to geom_density() II! Let's start by looking at the data set `cces`. Use `cces` to make a density plot with `age` on the x axis and `ideology` set to the aesthetics `color` and `fill`.

```{r den1D-II-1, exercise=TRUE, exercise.lines=6}


```

###

Great! As you can see, we have a lot of overlapping going on. Try setting the `alpha` parameter in `geom_density()` to 0.3.

```{r den1D-II-2, exercise=TRUE, exercise.lines=6}


```

###

Nice! Now try setting the `position` parameter in `geom_density()` to "fill". Then try setting it to "stack".

```{r den1D-II-3, exercise=TRUE, exercise.lines=7}


```

###

Great! Now add a limit to the x axis with an upper bound of 90 and a lower bound of 20. After you have done this, set the `linetype` parameter in `geom_density()` to `dotted`.

```{r den1D-II-4, exercise=TRUE, exercise.lines=8}


```

```{r den1D-II-4-hint, eval=FALSE}
Use xlim() to add a limit on the x axis
```

###

For your final challenge of geom_density() II, recreate the graph below made with data set `trains`

```{r}
trains %>%
  ggplot(aes(x = income, color = treatment)) +
    geom_density(position = "fill") +
    labs(title = "Age Distribution in the Conressional Election Study ")
```

```{r den1D-II-5, exercise=TRUE, exercise.lines=8}


```

## geom_density() III

Let's use `geom_density()` and the `diamonds` tibble to make a plot. Hit 'Run Code'.

```{r gd-1-1, exercise=TRUE, exercise.lines = 5}
diamonds %>% ggplot(aes(x = cut)) +
  geom_density()
```

###

Nice. Now, let's map `color` to the variable of the same name, `color`, from the `diamonds` tibble. Note that you can also use `fill` for `geom_density()`, but in this case it's not ideal because the colored areas overlap too much.

Let's also rewrite our legend with the `scale_color_discrete()` function. Give it the `name` "Diamond Color", and the `labels` "Best", "Great", "Good", "Decent", "Okay", "Not Good", and "Worst".

```{r gd-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `labs()` to give our plot some labels. Title our plot "Diamond Color And Price", our x-axis "Price (US Dollars)", and our y-axis "Number of Diamonds".

Let's also use `theme_light()` and `scale_color_brewer()` with `pallete` = "Set2" to change the look of our plot.


```{r gd-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now let's try something different. Set `position` to "stack", so it's a little easier to see the lines over eachother. This places the data from each consecutive color value over top of the data that's already been plotted, 'stacking' the data. Now, we can change our `color` mapping to `fill` (you will need to do this in the `scale()` functions as well).

Finally, let's use `theme(legend.position)` to move our legend to the "right" of our plot.

```{r gd-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Excellent. Now, use what you've learned about `geom_density()` to recreate the plot below. The brewer color palette is "Greens".

```{r}
diamonds %>% ggplot(aes(x = carat, color = cut)) +
  geom_density() +
    labs(title = "Distribution of Size in Diamonds",
         x = "Size (Carats)",
         y = "Density of Diamonds") +
    scale_color_brewer(palette = "Greens", name = "Diamond Quality")
```

```{r gd-1-5, exercise=TRUE, exercise.lines = 5}

```

## geom_density() IV

Let's make a plot using `geom_density()` and the `qscores` tibble, which records student evaluation data for Harvard classes. Map x to `rating`.

```{r gd-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's map `linetype` to `term`. Let's also give our legend some labels using `scale_linetype_discrete()`. Let's give it the `name` "Class Semester", and the `labels` "Fall 2018" and "Spring 2019".

```{r gd-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's use `labs()` to give our plot some labels. We can title our plot "Distribution of Harvard Class Student Evaluation Ratings", our x-axis "Rating", and our y-axis "Density of Classes".

Let's also add an `xlim()` function, to set the range of x values on our plot to (2.5, 5).

```{r gd-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's use `theme(legend.position)` to move our legend to the "bottom" of the plot. Let's also use `theme_classic` to change the look of the plot.

```{r gd-2-4, exercise=TRUE, exercise.lines = 5}

```


###

Good stuff. Now, use what you've learned about `geom_density()` to recreate the plot below.

```{r}
qscores %>% ggplot(aes(x = enrollment, color = term)) +
  geom_density() +
  scale_color_discrete(name = "Class Semester", labels = c("Fall 2018", "Spring 2019")) +
  xlim(0, 200) +
  labs(title = "Distribution of Students Enrolled in Harvard Classes",
       x = "Number of Students Enrolled",
       y = "Density of Classes")
```

```{r gd-2-5, exercise=TRUE, exercise.lines = 5}

```

## geom_bin2d() I

###

Welcome to geom_bin2d() I! In this tutorial, we will be learning how to make heatmaps. Let's begin by looking at the data set `diamonds`. Press "run code":

```{r bin-I-1, exercise=TRUE, exercise.lines=6}
diamonds %>%
  ggplot(aes(x = cut, y = carat)) +
    geom_bin2d()
```

###

Try changing the x axis variable to `price` and the y axis variable to `clarity`
```{r bin-I-2, exercise=TRUE, exercise.lines=6, eval=FALSE}
diamonds %>%
  ggplot(aes(x = ..., y = ...)) +
    geom_bin2d()
```

###

Just like in a histogram, in a heatmap, we can set the number of bins. Set the number of bins for our plot to 20.

```{r bin-I-3, exercise=TRUE, exercise.lines=6}

```

```{r bin-I-3-hint, eval=FALSE}
Set the number of bins inside of geom_bin2d()
```

###

Also like with histograms, we can set the binwidth. Try setting binwidth to 2000.

```{r bin-I-4, exercise=TRUE, exercise.lines=6}

```

```{r bin-I-4-hint, eval=FALSE}
Set binwidth inside of geom_bin2d()
```

###

Great! Now add  the title "Distribution of Diamond Cut and Price"

```{r bin-I-5, exercise=TRUE, exercise.lines=6}

```
```{r bin-I-5-hint, eval=FALSE}
Use labs()
```

## geom_bin2d() II

###

Welcome to geom_bin2d()! Let's first look at the data set `cces`. Use `cces` to make a heatmap with `education` on the x axis and `ideology` on the y axis.

```{r bin-II-1, exercise=TRUE, exercise.lines=6}

```

###
Nice! As you can see, our x axis tick mark labels are overlapping each other. Let's turn them vertical by setting their angle to 90 using theme().

```{r bin-II-2, exercise=TRUE, exercise.lines=6}

```

###

Great! Now use the function `theme(legend.position = "top")`to move the legend to the top

```{r bin-II-3, exercise=TRUE, exercise.lines=6}

```

###

Nice! Now facet the heatmap by `gender` and set the number of columns to 2
```{r bin-II-4, exercise=TRUE, exercise.lines=6}

```

```{r bin-II-4-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 2
```

###

For your final challenge, recreate the graph below made from data set `nhanes`.

```{r}
nhanes %>%
  ggplot(aes(x = hh_income, y = education)) +
    geom_bin2d() +
    facet_wrap(~gender, ncol = 2) +
    theme(axis.text.x = element_text(angle = 90))

```

```{r bin-II-5, exercise=TRUE, exercise.lines=8}

```

## geom_bin2d() III

Let's made a heatmap using `geom_bin2d()` and the `diamonds` tibble, which contains information on cut diamonds. Hit 'Run Code' to continue.


```{r gb2d-1-1, exercise=TRUE, exercise.lines = 5}
diamonds %>% 
  ggplot(aes(x = carat, y = price)) +
    geom_bin2d()
```

###

Good. `geom_bin2d()` is similar to a scatterplot or jittered scatterplot because it takes two continouous variables, but instead of plotting every individual point, it creates a heatmap of where the points are most concentrated, making it a better fit for big data.

Now, let's set `bins` to `60`, to give more detailed information on the distribution of our data points.

```{r gb2d-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Now, let's try adding some labels with `labs()`. Title our plot "Size and Price in Diamonds". Call the x-axis "Size (Carats)", and the y-axis "Price (US Dollars)".

```{r gb2d-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Good. Now, let's try changing the color scheme of our plot. Instead of `scale_fill_brewer()`, we use `scale_fill_distiller()`, because our variable is continuous, not categorical. Remember that `scale_..._distiller()` is actually just the continuous variable version of  `scale_..._brewer()`, and both can take the same palatte arguments.

For this task, we will be using `scale_fill_distiller()`, and setting our `palette` to `Spectral`.

```{r gb2d-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about `geom_bin2d()` to recreate the plot below.

```{r}
diamonds %>% ggplot(aes(x = depth, y = price)) +
  geom_bin2d() +
  labs(title = "Price and Depth in Diamonds",
       x = "Depth (Millimeters)",
       y = "Price (US Dollars)")
```

```{r gb2d-1-5, exercise=TRUE, exercise.lines = 5}

```

## geom_bin2d() IV

Let's make a heatmap using `geom_bin2d`, and the `qscores` tibble, which tracks Harvard student course evaluation information. Let's set x to `hours`, and y to `rating`.

```{r gb2d-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set the `binwidth` argument to 0.1, to give our plot's information a bit more detail. Let's also use `theme_dark()` to change the look of our plot.

```{r gb2d-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's use the `xlim()` and `ylim()` functions to remove the outliers and focus more on the bulk of our data. Set our `xlim()` to (2, 5) and our `ylim()` to (0, 15).


```{r gb2d-2-3, exercise=TRUE, exercise.lines = 5}

```

Good Work. Now, let's add some labels to both our plot and our legend, using the `labs()` and `scale()` functions. Let's title our plot "Harvard Class Student Evaluation Ratings by Weekly Work Hours", our x-axis "Weekly Work Hours", and our y-axis "Class Rating".

In order to change the name of our legend, we need to call the `scale_fill_continous()` function, even though it doesn't actually do anything on its own. Because we're working with a continuous variable mapped to `fill`, `scale_fill_continous()` is already the default setting. Legend titles, however, must be placed inside of a `scale_()` function corresponding to what they represent, in this case, `fill`.

Anyways, let's set the `name` of our legend "Number of Classes".

```{r gb2d-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about `geom_bin2d()` to recreate this plot.

```{r}
qscores %>% 
  ggplot(aes(x = enrollment, y = rating)) +
    geom_bin2d() +
    scale_fill_continuous(name = "Number of Classes") +
    labs(title = "Harvard Class Enrollment and Student Evaluation Ratings",
         x = "Number of Students Enrolled",
         y = "Class Rating") +
    xlim(0, 200)
```

```{r gb2d-2-5, exercise=TRUE, exercise.lines = 5}

```

## geom_density2d() I

###

Welcome to geom_density2d() I! We are first going to look at data from `diamonds` of which you are likely already familiar with. Let's start by running the code below:

```{r density-I-1, exercise=TRUE, exercise.lines=7}
diamonds %>%
  ggplot(aes(x = carat, y = price)) +
    geom_density2d()

```

###

Now try replacing the variable `carat` with `depth` on the x axis.

```{r density-I-2, exercise=TRUE, exercise.lines=7}


```

```{r smooth-I-2-hint, eval=FALSE}
diamonds %>%
  ggplot(aes(x = ..., y = price)) +
    geom_density2d()
```

###

Nice! Now set the `color` aesthetic to `cut`.

```{r density-I-3, exercise=TRUE, exercise.lines=7}


```

```{r density-I-3-hint, eval=FALSE}
Because color is an aesthetic, set it inside of aes()
```

###

Great! Now use labs() to title the graph "Diamond Price, Depth and Cut"

```{r density-I-4, exercise=TRUE, exercise.lines=7}


```

###

Recreate the graph below which I made using data set `qscores`:
```{r}

qscores %>%
  ggplot(aes(x = rating, y = hours, color = term)) +
    geom_density2d() +
      labs(title = "Harvard Class Workload and Rating")
```

```{r density-I-5, exercise=TRUE, exercise.lines=7}


```

## geom_density2d() II

###

Welcome to geom_density2d()! Let's start by looking at data set `mpg`. Use `mpg` to make a density plot with `displ` on the x axis, `hwy` on the y axis and `class` mapped to the color aesthetic.

```{r density-II-1, exercise=TRUE, exercise.lines=7}


```

###

Nice! Now set a lower limit of 0 and an upper limit of 30 on the y axis.

```{r density-II-2, exercise=TRUE, exercise.lines=7}


```

```{r density-II-2-hint, eval=FALSE}
use ylim()
```

###

Now instead of setting `class` to color, try facetting by `class` and setting the number of columns to 3

```{r density-II-3, exercise=TRUE, exercise.lines=7}


```

```{r density-II-3-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 3
```

###

Great! Now change the theme to light

```{r density-II-4, exercise=TRUE, exercise.lines=7}


```

```{r density-II-4-hint, eval=FALSE}
Use theme_light()
```

###

Nice! Now recreate this density plot that I made using data set `airquality`:

```{r}
airquality %>%
 ggplot(aes(x = Ozone, y = Temp)) +
  geom_density2d() +
  theme_minimal() +
  facet_wrap(~ Month, ncol = 3)
```

```{r density-II-5, exercise=TRUE, exercise.lines=7}


```

## geom_density2d() III

Let's make a density plot using `geom_density2d()` and the `faithful` tibble, which records information from eruptions of the Old Faithful Geyser. Hit 'Run Code'.

```{r gd2d-1-1, exercise=TRUE, exercise.lines = 5}
faithful %>% 
  ggplot(aes(x = eruptions, y = waiting)) +
    geom_density2d()
```

###

Nice. Now, let's map `linetype` to "dotdash", to change the look of our plot.

```{r gd2d-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Well Done. Now, let's change the theme of our plot using `theme_bw()`. Let's also set the `color` of our lines to "black".

```{r gd2d-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Good Stuff. Now, try setting our `xlim()` function to (0, 7), to a get a more complete view of the circles created by `geom_density2d`.

```{r gd2d-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about the `geom_density2d()` function to recreate the plot below.

```{r}
faithful %>% 
  ggplot(aes(x = waiting, y = eruptions)) +
    geom_density2d(color = "red") +
    labs(title = "Eruption Length and Waiting Time for Old Faithful Eruptions",
         x = "Waiting Time (Minutes)",
         y = "Eruption Length (Minutes)")
```

```{r gd2d-1-5, exercise=TRUE, exercise.lines = 7}

```

## geom_density2d() IV

Let's make a density plot using `geom_density2d()` and the `mpg` tibble, which records the fuel efficiencies of different car models. Let's map x to `cty`, and y to `hwy`.

```{r gd2d-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Let's say, for whatever reason, one desired to decrease the resolution of their `geom_density2d()` plot. You can do this by mapping `n` to the number of verticies you want on your polygons. Try it! Let's set `n` to `10`.

```{r gd2d-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, let's try mapping `color` to `class`. Notice how this creates a number of smaller density plots. Let's also add some labels the legend we just generated.

Note that this must be done inside of a `scale()` function that corresponds to `color`. In this case, because we are working with a categorical variable, we will use `scale_color_discrete`. Let's call our legend's `name` "Type of Car", and our variables "Sports Car", "Compact", "Midsize", "Minivan", "Pickup Truck", and "SUV".

```{r gd2d-2-3-hint, eval=FALSE}
sacle_...(name = ..., labels = c(..., ..., ...))
```

```{r gd2d-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice Work. Now, we can add some labels to the rest of our plot with `labs()`. Title our plot "Highway and City Fuel Efficiency in Different Car Types", our x-axis "City Miles Per Gallon", and our y-axis "Highway Miles Per Gallon".

Let's also move our legend to the "top" of the plot using `theme(legend.position)`, and change the color scheme of our plot with `scale_color_brewer()` using `palette` "Set1".

```{r gd2d-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good Stuff. Now, use what you've learned about `geom_density2d()` to replicate the plot below.

```{r gd2d-2-5, exercise=TRUE, exercise.lines = 5}
mpg %>% ggplot(aes(x = displ, y = hwy, linetype = drv)) +
  geom_density2d() +
  scale_color_discrete(name = "Type of Drive Train", labels = c("4 Wheel", "Front Only", "Rear Only")) +
  labs(title = "Engine Size and Highway Miles Per Gallon in Car Types",
       x = "Engine Size (Liters)",
       y = "Highway Miles Per Gallon")
```

## geom_countour_filled() I

Let's make a plot using `faithfuld`, a modified version of the `faithful` tibble you are familiar with, and `geom_contour_filled()`. `faithfuld` is different from `faithful` because it includes the `density` variable, which is important for plots made with `geom_contour_filled()`.

Hit 'Run Code'.

```{r gcf-1-1, exercise=TRUE, exercise.lines = 5}
faithfuld %>% ggplot(aes(x = eruptions, y = waiting, z = density)) +
  geom_contour_filled()
```

###

`geom_contour_filled()` and `geom_contour()` are unique functions, because unlike `geom_density2d()` or `geom_bin2d()`, they require a `density` variable to be mapped to their z coordinate. This makes it very hard to make a `geom_contour_filled()` plot with a data set without `density`.

Try making a plot with `geom_contour_filled()` and the `diamonds` tibble. Map x to `price`, y to `carat`, and z to `depth`.

```{r gcf-1-2, exercise=TRUE, exercise.lines = 5}

```

###

Weird, right? Even though the parameters for making a plot with `geom_contour_filled()` are very specific, many of the aesthetic settings you're familiar with still work with it. Try using `scale_fill_brewer(palette = "Purples")` to change the color scheme of the plot.

```{r gcf-1-3, exercise=TRUE, exercise.lines = 5}

```

###

Cool. We can also use `labs()` to add labels like with any other plot. Title our plot "Waiting Time and Eruption Duration from Old Faithful Geyser", our x-axis "Eruption Duration (Minutes)", and our y-axis "Waiting Time (Minutes)". We can also add to our `scale_fill_brewer()` function to set the `name` of our legend to "Density of Eruptions".

```{r gcf-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Nicely done. Now, use what you've learned about `geom_contour_filled()` to recreate the plot below. The color palette is the `Spectral` palette of `scale_fill_brewer()`.

```{r gcf-1-5, exercise=TRUE, exercise.lines = 5}
faithfuld %>% ggplot(aes(x = waiting, y = eruptions, z = density)) +
  geom_contour_filled() +
  scale_fill_brewer(palette = "Spectral", name = "Density of Eruptions") +
  labs(title = "Waiting Time and Eruption Duration from Old Faithful Geyser",
       x = "Waiting Time (Minutes)",
       y = "Eruption Duration (Minutes)")
```

## Advanced Plotting - `geom_point()`

For data set `Orange`, create a scatterplot with `age` on the x axis and `circumference` on the y axis.

```{r point-II-1, exercise=TRUE, exercise.lines=8}


```

```{r point-II-1-hint, eval=FALSE}
ggplot(data = Orange, aes(x = ..., y = ..., color = ...)) +
  geom_point()
```

###

Nice! Let's go back to the `qscores` data set. Use `qscores` to make a scatterplot with `hours` on the x axis and `enrollment` on the y axis. Then map the `term` variable to the `color` aesthetic and set alpha to 0.5.

```{r point-II-2, exercise=TRUE, exercise.lines=8}


```

```{r point-II-2-hint, eval=FALSE}

Set the alpha argument inside of geom_point() and the color inside of aes().

```

###

Now change the scale to square root (`sqrt`)
```{r point-II-3, exercise=TRUE, exercise.lines=8}


```

```{r point-II-3-hint, eval=FALSE}

Use the scale_y_sqrt() function.

```

###

Now let's make a scatterplot using the `diamonds` data set, with `price` on the x-axis, and `carat` on the y-axis.

```{r gp-2-1, exercise=TRUE, exercise.lines = 5}


```

###

Great! Now let's try adding some labels. Title the plot: "Carats and Price in Diamonds", and give it the caption: "The relationship between price and carats in diamonds."

```{r gp-2-2-hint, eval=FALSE}
Use the labs() function to create labels.
```


```{r gp-2-2, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + geom_point()

```

###

Perfect. Now, let's set the `alpha` of every point on the plot to 0.1, and correspond the `cut` attribute to color.

```{r gp-2-3-hint, eval=FALSE}
Color and alpha can be set within aes(), like x and y.
```


```{r gp-2-3, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + 
  geom_point() + 
  labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

Wonderful. Now, let's add a smooth trend line on top of the scatterplot, and scale the x-axis to log10.

```{r gp-2-4-hint, eval=FALSE}
Use geom_smooth() to create a trendline, and scale_..._log10() to rescale the plot.
```


```{r gp-2-4, exercise=TRUE, exercise.lines = 5}
ggplot(data = diamonds, aes(x = price, y = carat)) + 
  geom_point(aes(color = cut, alpha = 0.2)) + 
  labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

Nice! Now, let's move the legend position to below the plot, and set the theme of the plot to `bw`.

```{r gp-2-5-hint, eval=FALSE}
Use theme(legend.position = ) and theme_...().
```


```{r gp-2-5, exercise=TRUE, exercise.lines = 5}
  diamonds %>% ggplot(aes(x = price, y = carat), scale = log10()) +
    geom_point(aes(color = cut, alpha = 0.2)) +
    geom_smooth() +
    scale_x_log10() +
    labs(title = "Carats and Price in Diamonds", caption = "The relationship between price and carats in diamonds.")
```

## Advanced Plotting - `geom_jitter()`

Now let's use the dataset `nhanes` to make a scatterplot jittered by width .5, with `education` on the x axis, and `bmi` on the y axis.

```{r jit-II-1, exercise=TRUE, exercise.lines=6}

```

###

As you can see, there is still a lot of overplotting going on. To combat this, let's set alpha to 0.1. Let's also set the color aesthetic to `gender`

```{r jit-II-2, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-2-hint, eval=FALSE}
Set alpha inside of geom_jitter() and color inside of aes()
```

###

Nice! Let's now set a limit on the y-axis with an upper bound of 60 and a lower bound of 10.

```{r jit-II-3, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-3-hint, eval=FALSE}
use ylim()
```

###

Great! Let's now facet our graph by `gender` and set the number of columns to 1

```{r jit-II-4, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-4-hint, eval=FALSE}
Use facet_wrap() to facet and set ncol to 1.
```

###

Nice! Now set the x-axis labels at a 45 degree angle using theme()
```{r jit-II-5, exercise=TRUE, exercise.lines=6}

```

```{r jit-II-5-hint, eval=FALSE}
Inside theme, set axis.text.x to element_text(angle = ...)

```

###

Now let's make a jittered scatterplot using `geom_jitter()` and the `diamonds` tibble. Let's put `carat` on the y-axis, and `price` on the x-axis.

```{r gj-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. But, our plot looks a little sloppy and it's hard to see how our data is distributed. Let's try to minimize our overplotting by setting `size` to 1, `height` to 0.25, and `alpha` to 0.2.

```{r gj-2-2, exercise=TRUE, exercise.lines = 5}

```

###

That looks a bit better! Now, try adding a red trendline using `geom_smooth()`, with `method` set to the `lm` or linear mean of the points on the plot. Let's also use the `scale_x_log10` function to make the scale of the plot logarithmic.

```{r gj-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now let's add some labels. Title our plot "Size and Price in Diamonds", our x-axis "Price (US Dollars)", and our y-axis "Size (Carats)". While we're at it, let's also map `color` to `cut`. Do you think that Ideal quality diamonds will fall above or below the trendline? What about Fair quality diamonds?

```{r gj-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, use what you've learned to recreate the plot below. The color scheme is `scale_color_distiller()`, `width` = 1, and `alpha` = 0.2. `Length` is recorded as the variable `x`.

```{r}
ggplot(data = diamonds) +
  geom_jitter(aes(x = x, y = price, color = carat), width = 1, alpha = 0.2) +
  scale_color_distiller() +
  labs(title = "Length and Price in Cut Diamonds",
       x = "Length (Millimeters)",
       y = "Price (US Dollars)")
```

```{r gj-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_line()`

Let's revisit the dataset `economics`. Change the scale on the y-axis of the graph below to log base 10 and the color of the line to "blue".

```{r line-II-1, exercise=TRUE, exercise.lines=10}
ggplot(data = economics, aes(x = date, y = unemploy)) +
  geom_line() 
```

```{r line-II-1-hint, eval=FALSE}

Use scale_y_log10()

```

###

Nice! Now add commas to the y-axis.

```{r line-II-2, exercise=TRUE, exercise.lines=10}



```

```{r line-II-2-hint, eval=FALSE}

Use the scales library and set labels=scales::comma inside of the scale function.

```

###

Great! Now set the theme to minimalist using theme_minimal().

```{r line-II-3, exercise=TRUE, exercise.lines=10}



```

###

Nice! Now add the label "population" to the y axis and the title "Population Growth Over Time".

```{r line-II-4, exercise=TRUE, exercise.lines=10}



```

```{r line-II-4-hint, eval=FALSE}

Use labs()
```

###

Great! Now add a limit to the y axis with a lower bound of 225,000 and an upper bound of 300,000
```{r line-II-5, exercise=TRUE, exercise.lines=10}



```

```{r line-II-5-hint, eval=FALSE}

Use ylim().
```

<!-- JSE - more advanced plotting for line graphs -->
### 

Let's make a line plot using information in the `population` tibble, which annually records the populations of different nations.


```{r gl-1-1, exercise=TRUE, exercise.lines = 5}
country_pop <- population %>% 
  filter(country == "Canada") 

ggplot(data = country_pop, aes(x = year, y = population)) +
  geom_line()
```

###

Nice! Now try making a plot using x = `year`, y = `population`, but with data from "Australia".

```{r gl-1-2-hint, eval=FALSE}
population %>% filter(country == ...) %>% ggplot(aes(x = ..., y = ...)) +
  geom_line()
```

```{r gl-1-2, exercise=TRUE, exercise.lines = 5, eval=FALSE}
country_pop <- population %>%
  ...


```

###

Great, now let's try plotting the data from both countries on the same graph. Let's also set the `country` variable to `color`.

```{r gl-1-3-hint, eval=FALSE}
population %>% filter(country == ... | country == ...) %>% ggplot(aes(x = ..., y = ..., color = ...)) +
  geom_line()
```

```{r gl-1-3, exercise=TRUE, exercise.lines = 5, eval=FALSE}
country <- population %>%
  ...
```

###

Cool. Now, let's modify our graph with some different countries: "Japan", "China", and "India". While we're at it, let's use `labs()` to add some labels. Title the plot "Population Trends in Asian Countries", and label our x and y axis "Year" and "Population".

```{r gl-1-4-hint, eval=FALSE}
Use labs(title = ... +
           x = ... +
           y = ...)  to add labels.
```

```{r gl-1-4, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now, use what you've learned to recreate the plot below.

```{r}
population %>% 
  filter(country == "Germany" | country == "France" | country == "Italy") %>% 
  ggplot(aes(x = year, y = population, linetype = country, color = country)) +
    geom_line() +
    labs(title = "Population in European Countries",
       x = "Year",
       y = "Population")
```


```{r gl-1-5-hint, eval=FALSE}
Use `linetype = ...`
```

```{r gl-1-5, exercise=TRUE, exercise.lines = 5}

```

###

Let's make one more `line()` graph using the `economics` tibble, with x = `date`, and y = `unemploy`.

```{r gl-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Now, let's set the color of our line to "blue", and use the ylim() function so that our y-axis begins at 0, and ends at 16,000.

```{r gl-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great! Our plot looks good. That being said, it's a little bid misleading, because it doesn't account for the rise in population from 1970 to 2015.

Let's try making the y-axis show the percentage of the population that's unemployed, so the plot is a bit more useful. Keep in mind that there is no variable in `economics` that will directly tell us this figure. Note that if you're planning to copy and paste from the last question, you must remove our `ylim()` function.

```{r gl-2-3-hint, eval=FALSE}
Use the variables `unemploy` and `pop` to find the proportion of the population that is unemployed. Multiply this value by 100 to find the percentage.
```

```{r gl-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Now, let's add some labels. Title the plot "Unemployment by Year", our x-axis "Year", and our y-axis "Percentage of Population Unemployed".

```{r gl-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Good work. Now, use what you've learned to replicate this plot.

```{r}
economics %>% ggplot(aes(x = date)) +
  geom_line(aes(y = unemploy), color = "red") +
  geom_line(aes(y = pop), color = "blue") +
  labs(title = "Unemployment and Poulation Over Time",
       x = "Year",
       y = "Number of People")
```


```{r gl-2-5-hint, eval=FALSE}
You can use multiple `geom_line()` functions in the same `ggplot()` function.
```

```{r gl-2-5, exercise=TRUE, exercise.lines = 5}

```


## Advanced Plotting - `geom_histogram()` 

Let's keep working with our `qscores` histogram plot, which you can see below. See the message R gave us about bin widths? Change the bin width by setting the number of bins to 20.
```{r}
ggplot(data = qscores, aes(x = rating)) +
  geom_histogram(fill = "red4", color = "white") +
  labs(title = "Course Rating Distribution", y = "Count", x = "Rating")
```

```{r hist-II-1, exercise=TRUE, exercise.lines=7}
ggplot(data = qscores, aes(x = rating)) +
  geom_histogram(fill = "red4", color = "white") +
  labs(title = "Course Rating Distribution", y = "Count", x = "Rating")

```

```{r hist-II-1-hint, eval=FALSE}
Set the argument bins in geom_histogram() to 20.

```

###

Nice! Besides changing the number of bins, recall that we can change the bin width by setting it to a specific value. Change the plot so that the bins are .25 wide. (To do this you must delete the bins argument you set in the previous question)

```{r hist-II-2, exercise=TRUE, exercise.lines=7}


```

```{r hist-II-2-hint, eval=FALSE}
Set the argument binwidth in geom_histogram() to .25

```

###

Now facet the plot by `term` and set the number of columns to 2.

```{r hist-II-3, exercise=TRUE, exercise.lines=7}


```

```{r hist-II-3-hint, eval=FALSE}
Use facet_wrap() and set ncol to 2.
```

###

Great! Now change the theme to black and white using the `themes_bw()` function
```{r hist-II-4, exercise=TRUE, exercise.lines=7}


```

###

```{r}
ggplot(data = nhanes, aes(x = height)) +
    geom_histogram(color = "white", fill = "black", bins = 30) +
    facet_wrap(~ gender, ncol = 1)

```

Recreate the above histogram. It was made with data set `nhanes` with `height` on the x axis and facetted by `sex`.

```{r hist-II-5, exercise=TRUE, exercise.lines=7}


```

###

Let's use `mpg`, a tibble which contains data on the fuel efficiency of different types of cars, to make a `geom_histogram()` with x = `cty`.

```{r gh-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set `binwidth` to 1, and map `fill` to the variable `class`.


```{r gh-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Great work, now, let's try changing the color scheme of our plot to the `brewer` theme, using `scale_fill_brewer()`. Remember that setting `color` in a histogram will only change the outline of the bins, and you need to change `fill` to change the interior color of the bins. That being said, let's also set `color` to "black" to create a black outline around our bins.

```{r gh-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's set `position` to "fill", to get a better sense of the types of cars at each fuel economy value, not just the quantity. While we're at it, let's add some labels with labs(). Title our plot "Fuel Economy by Class of Car", our x-axis  "City Fuel Efficiency (Miles Per Gallon)", and our y-axis "Distribution of Car Models"

```{r gh-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Finally, use what you've learned about `geom_histogram()` to replicate the plot below.

```{r}
mpg %>% ggplot(aes(x = hwy, color = class)) +
  geom_histogram(fill = "white", bins = 5, position = "dodge") +
  labs(title = "Highway Fuel Economy by Car Type",
       x = "Miles Per Gallon (Highway)",
       y = "Number of Car Models")
```

```{r gh-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_boxplot()`

For dataset `diamonds`, create a boxplot with `clarity` on the x axis and `price` on the y axis

###

```{r box-II-1, exercise=TRUE, exercise.lines=10}

```

```{r box-II-1-hint, eval=FALSE}
Review geom_boxplot I
```
###

Try changing the scale of the y axis to log base 10

```{r box-II-2, exercise=TRUE, exercise.lines=10}

```

```{r box-II-2-hint,eval=FALSE}
Use the scale_y_log10() function
```

###

Nice job! For now, I have set the scale on the y axis back to continuous. In our first diamonds boxplot, R automatically set labels on the tick marks at 0, 5000, 10000 and 15000. Try changing this so that we have labels at 0, 90000 and 18000. After this, add dollar signs to your labels. Note, this is different from and does not use labs()!

```{r box-II-3, exercise=TRUE, exercise.lines=10}
diamonds %>%
  ggplot(aes(x = clarity, y = price))+
    geom_boxplot()+
    scale_y_continuous()
```

```{r box-II-3-hint,eval=FALSE}
Add breaks in the scale function to change label location. Also in the scale function, use the scales library to add dollars signs
```

###
Now facet the plot by `cut` and set the number of columns to 2

```{r box-II-4, exercise=TRUE, exercise.lines=10}
diamonds %>%
  ggplot(aes(x = clarity, y = price)) +
    geom_boxplot() +
    scale_y_continuous(breaks = c(0,9000,18000),labels = scales::dollar)
```

```{r box-II-4-hint,eval=FALSE}
Use facet_wrap() and set ncol to 2
```

###

```{r}
cces %>%
  ggplot(aes(x = age, y = ideology)) +
    geom_boxplot() +
    facet_wrap(~ race, ncol = 2) +
    labs(title = "Age, Ideology and Race in American Election Data")
```


Recreate the above boxplot from data set `cces`. Note that the plot is facetted by `race` with the number of columns set to 2.

```{r box-II-5, exercise=TRUE, exercise.lines=10}

```

```{r box-II-5-hint, eval=FALSE}
Use facet_wrap() to facet and labs() to create labels
```

###

Make a boxplot using the `diamonds` tibble with x = `cut`, and y = `price`.

```{r gb-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, use `coord_flip()` to convert the plot into a horizontal boxplot, and get rid of the outliers by setting `outlier.alpha` to 0. Note that you can also make outliers dissapear by setting `outlier.color` to "white".

```{r gb-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Wonderful. Now, let's use `labs()` to add some labels to our plot. Title the plot "Diamond Price by Quality", call the x-axis "Price (US Dollars)", and call the y-axis "Quality".

```{r gb-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Great! Now, let's zoom in on our plot by setting  `xlim()` to the vector `c(500, 7000)`. Remember that `xlim()` should be placed inside of the `coord_` function, in this case, `coord_flip`.

```{r gb-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Nice! Note that you can also zoom in on a plot by using the `xlim()` or `ylim()` functions outside of the `coord_` function without using a vector, but this is not ideal because it will disregard points outside of the zoom when calculating the average and percentile lines of a `boxplot()`. You can try this yourself by deleting the argument from the last question, and adding '+ xlim(7500)' to our plot. Notice how the averages are slightly different?

###

Now, use what you've learned to recreate the plot below.

```{r}
ggplot(data = diamonds, aes(x = price, y = carat, group = cut_interval(price, n = 4))) +
  geom_boxplot(outlier.alpha = 0.1, color = "red") +
  labs(title = "Size and Quality in Diamonds",
       x = "Price (US Dollars)",
       y = "Size (Carats)")
```

```{r gb-2-5-hint, eval=FALSE}
In order to use two continouous variables in a `boxplot()`, use the `group = cut_` function, in this case, `group = cut_interval(..., n = ...)`. Remember that this function must be inside of `aes()`.
```

```{r gb-2-5, exercise=TRUE, exercise.lines = 5}

```

## Advanced Plotting - `geom_violin()`

Let's use the `mpg` tibble, which tells us the fuel efficiency of different car models, to make a plot with `geom_violin()`. Let's map our x-axis to `class`, and our y-axis to `displ`.

```{r gv-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, let's add some percentile lines with `draw_quantiles` at 0.33 and 0.66. Let's also set `trim` to FALSE, to add tails to the violins. Both arguments should go inside the `geom_violin()` function.

```{r gv-2-2-hint, eval=FALSE}
draw_quantiles = c(..., ..., ...)
```

```{r gv-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Good. Now, let's add some labels with `labs()`. Let's title our plot "Engine Size by Car Type", our x-axis "Car Type", and our y-axis "Engine Size (Liters)". Let's also use `theme_void()` to give our plot a cleaner look.

```{r gv-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice Work. Now, let's try using layers to give our plot a bit more information. Use `geom_jitter()` to add a new layer to our plot, and map `color` to `maufacturer`, so we can get a sense of how car brand has to do with engine size. We use `geom_jitter()` over `geom_point()` in this scenario because it will spread points that occupy the same coordinates, making it easier to visualize the distribution of data. That being said, let's set `height` to 0, so all of the data points are accurate to their actual `displ` values. We can also set `width` to 0.2, so that the points stay more or less within the violins.

```{r gv-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Cool. Now use what you've learned to replicate the plot below.

```{r}
ggplot(data = mpg, aes(x = class, y = cty)) +
  geom_violin() +
  geom_jitter(aes(color = hwy, shape = drv), height = 0, width = 0.2)
```

```{r gv-2-5, exercise=TRUE, exercise.lines = 5}

```

###

## geom_violin() IV

###

Welcome to geom_violin() II! Let's start off right where we left off with geom_violin() I using data set `diamonds`. Use `geom_violin()` and the "gaussian" `kernel` to create a plot with `cut` on the x axis and `price` on the y axis.

```{r viol-II-1, exercise=TRUE, exercise.lines=8}

```

###

Great! Now use ylim() set a limit on the y axis with an upper bound of 10,000 and a lower bound of 0

```{r viol-II-2, exercise=TRUE, exercise.lines=8}

```

###

Nice! Now use `fill` to color the plot "blue"

```{r viol-II-3, exercise=TRUE, exercise.lines=8}

```

###

Great! Now use the scales library to add commas to the y axis

```{r viol-II-4, exercise=TRUE, exercise.lines=8}

```

###

Awesome! Now change the theme to dark using `theme_dark()`

```{r viol-II-5, exercise=TRUE, exercise.lines=8}

```

## More Layers

We can add more layers in order to customize the look and feel of your plots. This section will teach you how to:

* Add **labels** and **annotations** to your plots
* Change the appearance of your plot with a **theme**
* Modify the labels, title, and position of **legends**
* Provide breaks and labels for axes and legends using **scales**
* Adjust the **position** for barplots and scatterplots
* Break up a plot into several plots using **faceting**
* Change the **coordinate system** of a plot
* Add **statistical** transformations to a plot
* Adjust axes limits using **xlim** and **ylim**
* Adding text to a plot using **ggtext**

### Labels

#### labs()

Let's use the `diamonds` dataset to make a plot that uses boxplots to display the relationship between the `cut` and `price` variables from the diamonds dataset. This plot has been created and saved as an object called `p`.

The relationship in our plot is now easier to see, but that doesn't mean that everyone who sees our plot will spot it. We can draw their attention to the relationship with a label, like a title or a caption.

To do this, we will use the `labs()` function. You can think of `labs()` as an all purpose function for adding labels to a ggplot2 plot.

#### Titles

Give `labs()` a `title` argument to add a title.

```{r}
p <- ggplot(diamonds) +
  geom_boxplot(mapping = aes(x = cut, y = price))
```

```{r}
p <- ggplot(diamonds) +
  geom_boxplot(mapping = aes(x = cut, y = price))
```

```{r out.width = "80%"}
p + labs(title = "The title appears here")
```

#### Subtitles

Give `labs()` a `subtitle` argument to add a subtitle. If you use multiple arguments, remember to separate them with a comma.

```{r out.width = "80%"}
p + labs(title = "The title appears here",
         subtitle = "The subtitle appears here, slightly smaller")
```

#### Captions

Give `labs()` a `caption` argument to add a caption. I like to use captions to cite my data source.

```{r out.width = "80%"}
p + labs(title = "The title appears here",
         subtitle = "The subtitle appears here, slightly smaller",
         caption = "Captions appear at the bottom.")
```

#### Exercise - Labels

Plot `p` with a set of informative labels. For learning purposes, be sure to use a title, subtitle, and caption.

```{r r5-setup}
p <- ggplot(diamonds) +
  geom_boxplot(mapping = aes(x = cut, y = price)) +
  coord_cartesian(ylim = c(0, 7500))
```

```{r r5, exercise = TRUE}

```

#### Exercise 3 - Carat size?

Perhaps a diamond's cut is conflated with its carat size. If fair cut diamonds tend to be larger diamonds that would explain their larger prices. Let's test this.

Make a plot that displays the relationship between carat size, price, and cut for all diamonds. How do you interpret the results? Give your plot a title, subtitle, and caption that explain the plot and convey your conclusions.

If you are looking for a way to start, I recommend using a smooth line with color mapped to cut, perhaps overlaid on the background data.

```{r r6, exercise = TRUE}

```

```{r r6-hint, eval=FALSE}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_smooth(mapping = aes(color = cut), se = FALSE) +
  labs(...)
```

#### p1

Unlike `p`, our new plot uses color and has a legend. Let's save it to use later when we learn to customize colors and legends.

```{r out.width = "80%"}
p1 <- ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_smooth(mapping = aes(color = cut), se = FALSE) +
  labs(title = "Carat size vs. Price",
       subtitle = "Fair cut diamonds tend to be large, but they fetch the lowest prices for most carat sizes.",
       caption = "Data by Hadley Wickham")
```

### Themes

One of the most effective ways to control the look of your plot is with a theme.

#### What is a theme?

A theme describes how the non-data elements of your plot should look. For example, these two plots show the same data, but they use two very different themes.

```{r echo = FALSE, out.width ="50%", message = FALSE, warning = FALSE}
p1 + theme_bw()
p1 + theme_economist()
```

#### Theme functions

To change the theme of your plot, add a `theme_` function to your plot call. The ggplot2 package provides eight theme functions to choose from.

* `theme_bw()`
* `theme_classic()`
* `theme_dark()`
* `theme_gray()`
* `theme_light()`
* `theme_linedraw()`
* `theme_minimal()`
* `theme_void()`

Use the box below to plot `p1` with each of the themes. Which theme do you prefer? Which theme does ggplot2 apply by default?

```{r r7, exercise = TRUE}
p1 + theme_bw()
```

#### ggthemes

If you would like to give your graph a more complete makeover, the **ggthemes** package provides extra themes that imitate the graph styles of popular software packages and publications. These include:

* `theme_base()`
* `theme_calc()`
* `theme_economist()`
* `theme_economist_white()`
* `theme_excel()`
* `theme_few()`
* `theme_fivethirtyeight()`
* `theme_foundation()`
* `theme_gdocs()`
* `theme_hc()`
* `theme_igray()`
* `theme_map()`
* `theme_pander()`
* `theme_par()`
* `theme_solarized()`
* `theme_solarized_2()`
* `theme_solid()`
* `theme_stata()`
* `theme_tufte()`
* `theme_wsj()`

Try plotting `p1` with at least two or three of the themes mentioned above.

```{r r8, exercise = TRUE}
p1
```

#### Update p1

If you compare the ggtheme themes to the styles they imitate, you might notice something: the colors used to plot your data haven't changed. The colors are noticeably ggplot2 colors. In the next section, we'll look at how to customize this remaining part of your graph: the data elements.

Before we go on, I suggest that we update `p1` to use `theme_bw()`. It will make our next set of modifications easier to see.

```{r p1, out.width = "80%", messages = FALSE}
p1 <- p1 + theme_bw()
p1
```

### Legends

#### Customizing a legend

The last piece of a ggplot2 graph to customize is the legend. When it comes to legends, you can customize the:

* position of the legend within the graph
* the "type" of the legend, or whether a legend appears at all
* the title and labels in the legend

Customizing legends is a little more chaotic than customizing other parts of the graph, because the information that appears in a legend comes from several different places.

#### Positions

To change the position of a legend in a ggplot2 graph add one of the below to your plot call:

* `+ theme(legend.position = "bottom")`
* `+ theme(legend.position = "top")`
* `+ theme(legend.position = "left")`
* `+ theme(legend.position = "right")` (the default)

Try this now. Move the legend in `p_cont` to the bottom of the graph.

```{r r14, exercise = TRUE}

```

#### theme() vs. themes

Theme functions like `theme_grey()` and `theme_bw()` also adjust the legend position (among all of the other details they orchestrate). So if you use `theme(legend.position = "bottom")` in your plots, be sure to add it _after_ any `theme_` functions you call, like this

```{r r15, exercise = TRUE, exercise.eval = TRUE, out.width = "80%"}
ggplot(data = mpg) +
  geom_jitter(mapping = aes(x = displ, y = hwy, color = hwy)) +
  theme_bw() +
  theme(legend.position = "bottom")
```

If you do this, ggplot2 will apply all of the settings of `theme_bw()`, and then overwrite the legend position setting to "bottom" (instead of vice versa).

#### Types

You may have noticed that color and fill legends take two forms. If you map color (or fill) to a discrete variable, the legend will look like a standard legend. This is the case for the bottom legend below.

If you map color (or fill) to a continuous legend, your legend will look like a colorbar. This is the case in the top legend below. The color bar helps convey the continuous nature of the variable.

```{r plegend-setup}
p_legend <- ggplot(data = mpg) +
  geom_jitter(mapping = aes(x = displ, y = hwy, color = class, fill = hwy),
              shape = 21, size = 3, stroke = 1) +
  theme_bw()

p_legend
```

#### Changing type

You can use the `guides()` function to change the type or presence of each legend in the plot. To use `guides()`, type the name of the aesthetic whose legend you want to alter _as and argument name_. Then set it to one of

* `"legend"` - to force a legend to appear as a standard legend instead of a colorbar
* `"colorbar"` - to force a legend to appear as a colorbar instead of a standard legend. Note: this can only be used when the legend can be printed as a colorbar (in which case the default will be colorbar).
* `"none"` - to remove the legend entirely. This is useful when you have redundant aesthetic mappings, but it may make your plot indecipherable otherwise.

```{r plegend, out.width = "80%"}
p_legend + guides(fill = "legend", color = "none")
```

#### Exercise - guides()

Use `guides()` to remove each legend from the `p_legend` plot.

```{r r16, exercise = TRUE, exercise.setup = "plegend"}

```

#### Labels

To control the title and labels of a legend, you must turn to the `scale_` functions. Each `scale_` function takes a name and a labels argument, which it will use to build the legend associated with the scale. The labels argument should be a vector of strings that has one string for each label in the default legend.

So for example, you can adjust the legend of p1 with

```{r out.width = "80%"}
p1 + scale_color_brewer(name = "Cut Grade", 
                        labels = c("Very Bad", "Bad", "Mediocre", 
                                   "Nice", "Very Nice"))
```

#### What if?

This is handy, but it raises a question: what if you haven't invoked a `scale_` function to pass labels to? For example, the graph below relies on the default scales.

```{r echo = FALSE, out.width = "80%"}
p1
```

#### Default scales

In this case, you need to identify the default scale used by the plot and then manually add that scale to the plot, setting the labels as you do.

For example, our plot above relies on the default color scale for a discrete variable, which happens to be `scale_color_discrete()`. If you know this, you can relabel the legend like so:

```{r out.width = "80%"}
p1 + scale_color_discrete(name = "Cut Grade",
                          labels = c("Very Bad", "Bad", "Mediocre",
                                     "Nice", "Very Nice"))
```

#### Scale defaults

As you can see, it is handy to know which scales a ggplot2 graph will use by default. Here's a short list.

aesthetic	| variable   |	default
--------- | ---------- | -------------------------
x	        | continuous |	scale_x_continuous()
	        | discrete   |	scale_x_discrete()
y	        | continuous |	scale_y_continuous()
	        | discrete	 |  scale_y_discrete()
color	    | continuous |	scale_color_continuous()
	        | discrete	 |  scale_color_discrete()
fill	    | continuous |	scale_fill_continuous()
	        | discrete   |	scale_fill_discrete()
size	    | continuous |	scale_size()
shape	    | discrete	 | scale_shape()

#### Exercise - Legends

Use the list of scale defaults above to relabel the legend in `p_cont`. The legend should have the title "Highway MPG". Also place the legend at the top of the plot.

```{r r17, exercise = TRUE}
p1
```

```{r r17-hint, eval=FALSE}
p1 + scale_color_continuous(...) + theme(...)
```

#### Axis labels

In ggplot2, the axes are the "legends" associated with the $x$ and $y$ aesthetics. As a result, you can control axes titles and labels in the same way as you control legend titles and labels:

```{r}
p1 + scale_x_continuous(name = "Carat Size",
                        labels = c("Zero", "One", "Two",
                                   "Three", "Four", "Five"))
```

### Scales

#### What is a scale?

Every time you map an aesthetic to a variable, ggplot2 relies on a _scale_ to select the specific colors, sizes, or shapes to use for the values of your variable.

A scale is an R function that works like a mathematical function; it maps each value in a data space to a level in an aesthetic space. But it may be easier to think of a scale as a "palette." When you give your graph a color scale, you give it a palette of colors to use.

#### Using scales

ggplot2 chooses a pleasing set of scales to use whenever you make a graph. You can change or customize these scales by adding a scale function to your plot call.

For example, the code below plots `p1` in greyscale instead of the default colors.

```{r}
p1 + scale_color_grey()
```

#### A second example

You can add scales for every aesthetic mapping, including the $x$ and $y$ mappings (the code below log transforms the x and y axes).

```{r}
p1 +
  scale_x_log10() +
  scale_y_log10()
```

ggplot2 supplies over 50 scales to use. This may seem overwhelming, but the scales are organized according to an intuitive naming convention.

#### Naming convention

ggplot2 scale functions follow a naming convention. Each function name contains the same three elements in order, separated by underscores:

* The prefix `scale`
* the name of an aesthetic, which the scale adjusts (e.g. `color`, `fill`, `size`)
* a unique label for the scale (e.g. `grey`, `brewer`, `manual`)

`scale_shape_manual()` and `scale_x_continuous()` are examples of the naming scheme.

You can see the complete list of scale names at [http://ggplot2.tidyverse.org/reference/](http://ggplot2.tidyverse.org/reference/). In this tutorial, we will focus on scales that work with the color aesthetic.

#### Discrete vs. continuous

Scales specialize in either _discrete_ variables or _continuous_ variables. In other words, you would use a different set of scales to map a discrete variable, like diamond clarity, than you would use to map a continuous variable, like diamond price.

```{r q1, echo = FALSE}
question("Which type of variable does `p1` map to the color aesthetic?",
         answer("Discrete", correct = TRUE, message = "p1 maps color to cut, a discrete variable with five distinct levels."),
         answer("Continuous"),
         allow_retry = TRUE)
```

#### scale_color_brewer

One of the most useful color palettes for discrete variables is `scale_color_brewer()` (`scale_fill_brewer()` if you are working with fill. Run the code below to see the effect of the scale.

```{r make_p1, include = FALSE}
p1 <- ggplot(data = diamonds, 
             mapping = aes(x = carat, y = price)) +
    geom_smooth(mapping = aes(color = cut), se = FALSE) +
    labs(title = "Carat size vs. Price",
         subtitle = "Fair cut diamonds tend to be large, but they fetch the lowest prices for most carat sizes.",
         caption = "Data by Hadley Wickham") + 
  theme_bw()
```

```{r r9, exercise = TRUE, warning = FALSE, message = FALSE, exercise.setup="make_p1"}
p1 + scale_color_brewer()
```

#### RColorBrewer

The RColorBrewer package contains a variety of palettes developed by Cynthis Brewer. Each palette is designed to look pleasing as well as to differentiate between the values represented by the palette. You can learn more about the color brewer project at [colorbrewer2.org](http://colorbrewer2.org).

Altogether, the RColorBrewer package contains 35 palettes. You can see each palette and its name by running `RColorBrewer::display.brewer.all()`. Try it below.

```{r r10, exercise = TRUE, warning = FALSE, message = FALSE, fig.width=4, fig.height = 7}

```

#### Brewer palettes

By default, `scale_color_brewer()` will use the "Blues" palette from the RColorBrewer package. To use a different RColorBrewer palette, set the palette argument of `scale_color_brewer()` to one of the RColorBrewer palette names, surrounded by quotation marks, e.g.

```{r warnings = FALSE, out.width = "80%"}
p1 + scale_color_brewer(palette = "Purples")
```

#### Exercise - scale_color_brewer()

Recreate the graph below, which uses a different palette from the RColorBrewer package.

```{r echo = FALSE, out.width = "80%"}
p1 + scale_color_brewer(palette = "Spectral")
```

```{r r11, exercise = TRUE, warning = FALSE, message = FALSE, exercise.setup="make_p1"}


```

```{r r11-hint, eval=FALSE}
palette = "Spectral"
```

#### Continuous colors

`scale_color_brewer()` works with discrete variables, but what if your plot maps color to a continuous variable?

Since we do not have a plot that applies color to a continuous variable, let's make one.

```{r}
p_cont <- ggplot(data = mpg) +
  geom_jitter(mapping = aes(x = displ, y = hwy, color = hwy)) +
  theme_bw()

p_cont
```

#### Discrete vs. continuous in action

If we apply `scale_color_brewer()` to our new plot, we get an error message that confirms what you know: you cannot use a scale that is built for discrete variables to customize the mapping to a continuous variable. Uncomment the code to see the error.

```{r cont, exercise = TRUE}
# p_cont + scale_color_brewer()
```

#### distiller

Luckily, `scale_color_brewer()` has a comes with a continuous analogue named `scale_color_distiller()` (also `scale_fill_distiller()`).

Use `scale_color_distiller()` just as you would `scale_color_brewer()`. `scale_color_distiller()` will take any RColorBrewer palette, and interpolate between colors as necessary to provide an entire continuous range of colors.

So for example, we could reuse the Spectral palette in our continuous plot

```{r}
p_cont + scale_color_distiller(palette = "Spectral")
```

#### Exercise - scale_color_distiller()

Recreate the graph below, which uses a different palette from the RColorBrewer package.

```{r echo = FALSE, out.width = "80%"}
p_cont + scale_color_distiller(palette = "BrBG")
```

```{r r12, exercise = TRUE, warning = FALSE, message = FALSE, exercise.setup="make_p1"}

```

#### viridis

The viridis package contains a collection of very good looking color palettes for continuous variables. Each palette is designed to show the gradation of continuous values in an attractive, and perceptionally uniform way (no range of values appears more important than another). As a bonus, the palettes are both color blind and black and white printer friendly!

To add a viridis palette, use `scale_color_viridis()` or `scale_fill_viridis()`, both of which come in the viridis package.

```{r}
p_cont + scale_color_viridis()
```

#### viridis options

Altogether, the viridis package comes with four color palettes, named magma, plasma, inferno, and viridis.

However, you do not select the palettes by name. To select a viridis color palette, set the `option` argument of `scale_color_viridis()` to one of `"A"` (magma), `"B"` (plasma), `"C"` (inferno), or `"D"` (viridis).

Try each option with `p_cont` below. Determine which is the default.

```{r r13, exercise = TRUE, warning = FALSE, message = FALSE, exercise.setup="make_p1"}

```

### Positions

### Faceting

### Coordinate Systems

### Stats

### Adjusting Axes Limits

### Adding Text to a Plot

## Data Analysis using the Tidyverse I

###


Before we get started, load the package `PPBDS.data`

```{r data-I-1, exercise=TRUE, exercise.lines=3}

```

###

Let's take a `glimpse` at the data set `cces`. Press "run code".

```{r data-I-2, exercise=TRUE, exercise.lines=6}
glimpse(cces)
```

###

Now that you've seen the different variables in `cces`, select() `age`, `state`,  and `gender`

```{r data-I-3, exercise=TRUE, exercise.lines=6}
cces
```

```{r data-I-3-hint, eval=FALSE}
remember to pipe!
```

###

Let's filter() our code from the previous question so that we are only looking at rows where state == "Massachusetts" and gender == "Female"

```{r data-I-4, exercise=TRUE, exercise.lines=6}


```

```{r data-I-4-hint, eval=FALSE}
remember to use the double ==
```

###

Now use arrange() to organize our code by descending order of age

```{r data-I-5, exercise=TRUE, exercise.lines=6}

```

```{r data-I-5-hint, eval=FALSE}
remember to include desc()
```

###

Great! Now use summarize() to find the mean and median ages from our filtered data

```{r data-I-6, exercise=TRUE, exercise.lines=6}

```

###

Awesome! So let's recap what we just did. We first selected specific variables to focus on and then filtered to narrow down our search. We then arranged by descending order of age (although this was unnecessary in terms of achieving our specific end goal). Then, from that data, we found the mean and median age with summarize(). Through these steps, we found the mean and median ages of women from Massachusetts in the survey. With these next couple questions, I will be asking you to do this yourself. Find the mean age of liberal men from California:

```{r data-I-7, exercise=TRUE, exercise.lines=7}

```

```{r data-I-7-hint,eval=FALSE}
If some of the values apply to unfamiliar variables, feel free to always take a glimpse() back at the data set
```

###

Did you get 47.2? If so, awesome job! If not, look back at your code. For this next one, find the median age of divorced female Texans who attended "Some College":

```{r data-I-8, exercise=TRUE, exercise.lines=7}

```

###

The correct answer is 56. If you got something different, look back at your code. Congratulations on finishing data_analysis I!

## Data Analysis using the Tidyverse II

###

Welcome to data_analysis II! For this tutorial, we will be focusing on the data set `nhanes`. `nhanes` is a really big data set and there are many things we can do with its data, but let's say we wanted to make a graph using data on `height` and `weight` from the 200 youngest black males. How would we go about doing this? Well first, we would`select()` the variables we want to focus on, in this case `height`, `weight`, `age`, `race`, and `gender`.  Try doing this below:

```{r data-II-1, exercise=TRUE, exercise.lines=6}


```

###

So what would we do next? We want to narrow down our data to only black males, so let's use `filter()` to create a tibble made up of rows from `nhanes` where race == "Black" and gender == "Male". Do this below:

```{r data-II-2, exercise=TRUE, exercise.lines=6}


```

###

Great! So what now? Well, we want to look at the youngest black males. To do this, we would have to `arrange()` by age. Do this below:

```{r data-II-3, exercise=TRUE, exercise.lines=6}


```

###

Nice! Now use `slice()` to isolate the 200 rows with the lowest age value.

```{r data-II-4, exercise=TRUE, exercise.lines=6}


```

```{r data-II-4-hint, eval=FALSE}

Because of the way we arranged the data, the 200 rows with the lowest age value would be the first 200

```

###

Awesome! We now have our tibble! Now use `geom_smooth()` to create a graph with `weight` on the x axis and `height` on the y axis

```{r data-II-5, exercise=TRUE, exercise.lines=6}


```

## Data Analysis using the Tidyverse III

###

Welcome to data_analysis II! For this tutorial, we are going to be focusing on the data set `qscores`, which includes data on Harvard courses from the 2018-19 school year. Let's start by grouping `qscores` by `department`

```{r data-III-1, exercise=TRUE, exercise.lines=3}

```

###

Now use `summarize()` to find the mean rating for each of `department` in our grouped tibble

```{r data-III-2, exercise=TRUE, exercise.lines=6}

```

###

Nice! Now use `arrange` to order our data by descending mean rating
```{r data-III-3, exercise=TRUE, exercise.lines=6}


```

###

Great! As you can see, the tibble we have just created lists the different departments at Harvard included in `qscores` and their average rating. There's a lot of different things we can do this with this data, but let's say we wanted to make a plot with only the top 10 average rated departments. We would need to make a tibble to do this right? Use `slice()` to create this tibble

```{r data-III-4, exercise=TRUE, exercise.lines=6}


```

###

Fantastic! Now use this tibble you created to make a bar plot with `department` on the x axis and `mean` on the y axis (notice how are new tibble uses variables not in `qscores`)

```{r data-III-5, exercise=TRUE, exercise.lines=6}


```

###

Awesome! Let's start fresh from the original `qscores` data set again. Word just came in that Harvard is switching to a rating scale out of 10 for the next term! Upper admin wants to be able to compare data from last year to the next term, so use mutate to overwrite the original `qscores` with the new variable `rating_2` equal to two times the variable `rating`. I have started it for you:

```{r data-III-6, exercise=TRUE, exercise.lines=6, eval=FALSE}
qscores <- qscores %>%


```

###

Now use summarize() to find the standard deviation of `rating_2`

```{r data-III-7, exercise=TRUE, exercise.lines=6, eval=FALSE}
qscores <- qscores %>%
  mutate(rating_2 = rating * 2)

qscores %>%


```

## Data Analysis using the Tidyverse IV

Press the 'Run Code' button to load `PPBDS.data`.


```{r da-1-1, exercise=TRUE, exercise.lines = 5}
library(PPBDS.data)
```

###

Great! Now, select `Month`, `Day`, and `Temp` from the `airquality` dataset, which measures different atmospheric measurements in New York.

```{r da-1-2-hint, eval=FALSE}
Use select(...).
```

```{r da-1-2, exercise=TRUE, exercise.lines = 5}
airquality
```

###

Now, let's use `glimpse()` on our data set to take a good look at it.

```{r da-1-3-hint, eval=FALSE}
Use glimpse().
```

```{r da-1-3, exercise=TRUE, exercise.lines = 5}
airquality %>%
  select(Month, Day, Temp)
```

###

Great, now, use what you've learned from the textbook to calcul   ate the average of the `Temp` variable. Let's call this value `average`.

```{r da-1-4-hint, eval=FALSE}
Use summarise(average = mean(...)).
```

```{r da-1-4, exercise=TRUE, exercise.lines = 5}
airquality %>%
  select(Month, Day, Temp)
```

###

Nice job! Finally, use everything you've learned so far to calculate the maximum Temp value of every month. We can call this variable `maxTemp`. Then, sort them from the highest value to the lowest.

```{r da-1-5-hint, eval=FALSE}
You will use group_by(...) and arrange(desc()). If you are having more trouble, refer to the textbook.
```

```{r da-1-5, exercise=TRUE, exercise.lines = 5, eval=FALSE}
airquality %>%
  select(Month, Day, Temp)
```

## Data Analysis using the Tidyverse V

Let's do some data wrangling with the `mpg` tibble, which contains fuel efficiency data on different types of cars. Let's start by loading the data set, and using `select()` to pick out the `cty` and `class` variables.

```{r da-2-1, exercise=TRUE, exercise.lines = 5}

```

###

Let's say, for whatever reason, we wanted to remove all cars with their `manufacturer` == "chevrolet" from our data. We could do this using the `filter()` function and the `!=` symbol.  Try it!

Remember that this must be done BEFORE we use `select()`, which removes the `manufacturer` column altogether.

```{r da-2-2, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Now, let's use `group_by()` to split up our data by `class`.

```{r da-2-3, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `arrange()` to sort our `cty` values from lowest to highest within their respective classes.

Note that if you want to sort your data from highest to lowest, you can use `arrange(desc(...))`.

```{r da-2-4, exercise=TRUE, exercise.lines = 5}

```

###

Nice work. Now, let's use `summarise()` to calculate the `mean` of the `cty` values in each class. We can save our results as a new variable, called `ctyAverage`

```{r da-2-5, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. But let's say we're experimenting with a new type of gasoline that's twice as efficient as the traditional kind that the data in `mpg` was recorded with.

We could calculate the predicted City MPG with this new fuel using `mutate()`. Use `mutate()` to create a new variable, `ctyAverage2`, that's 2x `ctyAverage`.

```{r da-2-6, exercise=TRUE, exercise.lines = 5}

```

###

Excellent work. Now, use what you've learned about data wrangling to replicate the result blow.

Information from the `compact` class in not in the final data set.

```{r}
mpg %>%
  filter(class != "compact") %>%
  select(displ, manufacturer) %>%
  group_by(manufacturer) %>%
  summarize(displMedian = median(displ)) %>%
  arrange(desc(displMedian))
```

```{r da-2-7, exercise=TRUE, exercise.lines = 5}

```

## Data Analysis using the Tidyverse VI

Let's do some data wrangling with the `qscores` tibble, which contains data from student course evaluations at Harvard.

Begin by using `select()` to pick out the `term`, `rating`, and `enrollment` variables.

```{r da-3-1, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Let's use `filter()` so we only account for classes with a rating above 3.0.

```{r da-3-2, exercise=TRUE, exercise.lines = 5}

```

###

Good stuff. Now, let's use `group_by()` to divide our data by `term`.

```{r da-3-3, exercise=TRUE, exercise.lines = 5}

```

###

Nice. Let's say our goal was to calculate the average number of students in a Harvard class for each term a month into the term. But let's not take the average yet, there are still some factors we haven't accounted for yet.

Let's say on average, one tenth of all students drop a class by one month into the term, and two students are absent per class. We can calculate this by using `mutate()` to multiply `enrollment` by 9/10 and then subtract 2. Try it!

```{r da-3-4, exercise=TRUE, exercise.lines = 5}

```

###

Great. Now we can use `summarise()` to find the `mean` of `enrollment`. We can call this new variable `avgEnrollment`.

```{r da-3-5, exercise=TRUE, exercise.lines = 5}

```

###

Nice work. Let's also use `summarise()` to find the `min()` and `max()` of enrollment for each term. We can call these new variables `minEnrollment` and `maxEnrollment` respectively.

```{r da-3-6, exercise=TRUE, exercise.lines = 5}

```

###

Well done. Now, use what you've learned about data wrangling to recreate the dataset below.

The dataset only takes into account classes with an enrollment of at least 25. To calculate the devation from the median of a variable, use `mad()`, which stands for Median Absolute Deviation

```{r}
qscores %>%
  select(rating, department, enrollment) %>%
  filter(enrollment > 25) %>%
  group_by(department) %>%
  summarise(medianRating = median(rating),
            deviation = mad(rating))
```

```{r da-3-7, exercise=TRUE, exercise.lines = 5}

```

## Submit

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```
